<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[程序分析]]></title>
    <url>%2F2017%2F08%2F28%2F%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在计算机科学中，程序分析指的是对计算机程序进行自动分析的过程，包括程序正确性，健壮性，安全性以及活跃性的分析。程序分析主要关注于两个方面：程序优化以及程序正确性。前者着眼于提升程序的性能并减少资源的使用，而后者着重于确保程序行为就是它应该有的行为。 程序分析既可以在不执行程序的情况下进行（即 静态分析），也能在运行时进行（即动态分析），或者结合两者来进行。 静态程序分析 (Static program analysis)静态分析能够在程序开发阶段就发现程序的缺陷，而这些缺陷相比于测试阶段所发现的缺陷更加易于修改，因为静态分析指向的是缺陷的根源。而由于静态分析的计算不确定性，这种机制太宽松且不完整。静态分析尽管有一定的局限性，但首先能够减少缺陷数量，其次对低缺陷提供了有力的保证。 控制流分析 (Control-flow analysis)控制流分析的目的是获取程序执行过程中的不同位置哪些函数可以被调用的相关信息。收集后的信息可以用控制流图（control flow graph CFG）来进行表示，其中的结点就是程序的某一段指令，而边代表的就是控制流。通过识别代码块以及循环结构，控制流图 CFG 成为了编译器优化的一个入手点。 数据流分析 (Data-flow analysis)数据流分析是一项用于收集程序每个位置处的值以及它们如何随着时间变化相关信息的技术。这项技术通常被用于优化代码。其中最有名的就是 Taint checking，它假设所有由用户提供数据的变量都是不安全的，然后防止这些数据被使用，直到被脱毒处理。这项技术通常用于预防 SQL 注入攻击。 抽象解释 (Abstract interpretation)抽象解释允许对一个程序的可能执行进行信息抽取，而不用实际地执行程序。编译器可以利用这些信息来寻找可能的优化或证明程序不存在某一类的bug。 类型系统 (Type systems)类型系统将类型绑定到满足特定需求的程序上。其目的是为了挑选出一个语言程序的子集，而这个子集被认为在某个性质上是正确的。 类型检查 （Type checking）——验证程序是否能够被类型系统所接受 类型检查在编程中被用于约束程序对象的使用及其行为。通常由编译器或解释器来完成。类型检查同样有利于预防缺陷，确保一个有符号数不会被赋给一个无符号变量。类型检查可以被静态地进行（即 编译时），动态地进行（即 运行时），或二者结合来进行。 效果系统 （Effect systems）效果系统是一个形式化的系统，用于研究执行程序所具有的效果。一个效果包括完成了什么以及什么将要被完成，通常指效果类型和位置。 模型检测 （model checking）模型检测指的是寻找一种严格的、形式化的并且自动化的方法来验证某个给定模型（model）是否符合其给定规格（specification）的问题。由于系统具有有限状态的性质，而且模型和系统都可以使用逻辑公式（logical formulas）来进行表示，因而可以使用高效的算法来验证系统是否违反了某些规格。 动态程序分析 （Dynamic program analysis）动态分析可以利用程序运行时的相关信息来提升分析的精度，并提供运行时的保护，但是一次只能分析程序的单个执行，并且因为运行时的检查，会降低程序的性能。 测试（Testing）软件被测试用于保证其质量并确保其如预期所料、以可靠的方式运行，并且不和其他具有相关功能的软件发生冲突。进行测试，就是执行一个带有输入的程序，然后对其行为以及产生的输出进行评估的过程。即使没有特定的安全需求，也要进行额外的安全测试，以此保证攻击者无法篡改软件并偷取信息，中断程序的正常执行或利用它作为枢轴攻击它的用户。 监视 （Monitoring）程序监视记录有关程序的各种信息，比如 资源占用，事件与交互的情况，因而可以用于审查来发现程序的异常行为，进一步可以精确地定位到异常行为的根源。另外，它可以用于安全审计（Security audits）。自动的程序监视有时候被称为运行时验证 （Runtime Verification）。 程序切片 （Program slicing）对于一个给定的程序行为子集，程序切片是对程序不断裁剪，直到产生一个仍能产生所选择行为的最小形式。这个裁剪后的程序就被称为是一个“切片”，它是原始程序对于该特定行为子集的如实表达的部分。通常，寻找一个切片是一个不可解问题，但通过将变量集合值作为目标行为子集的方式，利用数据流分析，可以获取到近似的切片。这些切片通常在调试过程中被开发者用于定位错误的源头。]]></content>
      <categories>
        <category>程序分析</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 设置静态 IP]]></title>
    <url>%2F2016%2F12%2F20%2FCentOS-%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%2F</url>
    <content type="text"><![CDATA[CentOs 设置静态 IP大纲 修改网卡配置/etc/sysconfig/network-scripts/ifcfg-eth0，设置静态ip 修改网关配置/etc/sysconfig/network，设置网关地址 设置DNS服务器/etc/resolv.conf 重启网卡 sudo /etc/init.d/network restart 修改网卡配置 编辑： 1$ sudo vi /etc/sysconfig/network-scripts/ifcfg-eth0 123456789101112131415DEVICE=eth0TYPE=EthernetONBOOT=yesNM_CONTROLLED=yesBOOTPROTO=staticDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=yesIPV6INIT=noNAME=&quot;System eth0&quot;USERCTL=noIPADDR=172.21.0.16DNS2=172.21.1.2DNS1=172.21.1.1 DEVICE=eth0 #描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0 BOOTPROTO=static #设置网卡获得ip地址的方式，可能的选项为static，dhcp或bootp，分别对应静态指定的 ip地址，通过dhcp协议获得的ip地址，通过bootp协议获得的ip地址 BROADCAST=192.168.0.255 #对应的子网广播地址 HWADDR=00:07:E9:05:E8:B4 #对应的网卡物理地址 IPADDR=12.168.0.33 #如果设置网卡获得 ip地址的方式为静态指定，此字段就指定了网卡对应的ip地址 NETMASK=255.255.255.0 #网卡对应的网络掩码 NETWORK=192.168.0.0 #网卡对应的网络地址 修改网关配置编辑： 1$ sudo vi /etc/sysconfig/network 修改后如下： 123NETWORKING=yesAHOSTNAME=wwwGATEWAY=172.21.0.1 NETWORKING=yes(表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动) HOSTNAME=centos(设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应) GATEWAY=192.168.0.1(设置本机连接的网关的IP地址。) 我在修改这里打开编辑时前三项已经默认有了所以只增加了GATEWAY 修改DNS 配置编辑： 1$ sudo vi /etc/resolv.conf 修改后如下： 123; generated by /sbin/dhclient-scriptnameserver 172.21.1.1nameserver 172.21.1.2 nameserver 即是DNS服务器ＩＰ地址，第一个是首选，第二个是备用。 重启网络服务执行命令： 1$ sudo service network restart 或 1$ sudo /etc/init.d/network restart]]></content>
      <tags>
        <tag>linux 服务器管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning.Groovy]]></title>
    <url>%2F2016%2F07%2F10%2FLearning-Groovy%2F</url>
    <content type="text"><![CDATA[Learning GroovyInstallStep: Downloar binary or installer from Groovy official site Extract binary archive file or Install with Installer Open a terminal, type groovy --version to check if groovy has been installed successfully problem: If you has set CLASSPATH enviroment variable, there will be some odd exception. solution: You need to remove CLASSAPATH enviroment variable.]]></content>
  </entry>
  <entry>
    <title><![CDATA[统计代码行数]]></title>
    <url>%2F2016%2F07%2F06%2F%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0%2F</url>
    <content type="text"><![CDATA[统计代码行数命令如下1$ find . -name &quot;*.java&quot; | xargs wc -l 命令分解1$ find . -name &quot;.java&quot; 这一步，是找出当前目录子目录下所有的.java文件 1xargs wc -l xargs 是将前一步一系列的.java文件分块，一个个传给wc命令，wc -l 命令用于统计一个文件的行数 多个后缀名的文件1$ find . -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.rss&quot; | xargs wc -l 注意其中后缀名的双引号不用也可以。]]></content>
      <tags>
        <tag>实用命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j-原理]]></title>
    <url>%2F2016%2F05%2F21%2Flog4j-%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[log4j 1.x 原理 log4j 2.x在配置方式方式更加灵活，功能更强大，速度也有所提升，但是也更复杂了，针对大部分中小项目的话，简单实用的1.x系列就足够用了。 log4j 组成 日志信息的优先级 ERROR WARN INFO DEBUG 日志信息的输出目的地 控制台 文件 日志信息的输出格式 参看 log4j 类图 Logger - 日志写出器，供程序员输出日志信息 Appender - 日志目的地，把格式化好的日志信息输出到指定的地方去 ConsoleAppender - 目的地为控制台的 Appender FileAppender - 目的地为文件的 Appender RollingFileAppender - 目的地为大小受限的文件的 Appender Layout - 日志格式化器，用来把程序员的 logging request 格式化成字符串 PatternLayout - 用指定的 pattern 格式化 logging request 的 Layout log4j 配置两种配置文件： log4j.xml log4j.properties 也可以直接用代码设置相关配置 配置步骤 配置 logger 配置 appender 配置 layout 配置 logger配置根Logger，其语法为： log4j.rootLogger = [ level ] , appenderName, appenderName, … 其中，level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。 Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。 比如在这里定 义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。 appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。 配置 Appenderlog4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.option = valueN Log4j提供的appender有以下几种： org.apache.log4j.ConsoleAppender（控制台）， org.apache.log4j.FileAppender（文件）， org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件） org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件） org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方） 配置 layoutlog4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.option1 = value1 … log4j.appender.appenderName.layout.option = valueN Log4j提供的layout有以下几种： org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout（可以灵活地指定布局模式） org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下：%m | 输出代码中指定的消息 %p | 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r | 输出自应用启动到输出该log信息耗费的毫秒数 %c | 输出所属的类目，通常就是所在类的全名 %t | 输出产生该日志事件的线程名 %n | 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n” %d | 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm : ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %l | 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j-使用]]></title>
    <url>%2F2016%2F05%2F21%2Flog4j-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[使用步骤 获取logger 读取配置文件 插入记录信息 获取 logger使用Log4j，第一步就是获取日志记录器，这个记录器将负责控制日志信息。其语法为： public static Logger getLogger( String name) 通过指定的名字获得记录器，如果必要的话，则为这个名字创建一个新的记录器。Name一般取本类的名字，比如： public static Logger logger = Logger.getLogger ( Testlog4j.class.getName () ) 读取配置文件当获得了日志记录器之后，第二步将配置Log4j环境，其语法为： BasicConfigurator.configure () //自动快速地使用缺省Log4j环境 PropertyConfigurator.configure ( String configFilename) //读取使用Java的 porperties 文件编写的配置文件。 DOMConfigurator.configure ( String filename ) //读取XML形式的配置文件。 插入记录信息（格式化日志信息）Logger.debug ( Object message ) ; Logger.info ( Object message ) ; Logger.warn ( Object message ) ; Logger.error ( Object message ) ; 示例代码HelloLog4j.javaimport org.apache.log4j.Logger; public class HelloLog4j { private static Logger logger = Logger.getLogger(HelloLog4j.class); /** * @param args */ public static void main(String[] args) { // System.out.println(&quot;This is println message.&quot;); // 记录debug级别的信息 logger.debug(&quot;This is debug message.&quot;); // 记录info级别的信息 logger.info(&quot;This is info message.&quot;); // 记录error级别的信息 logger.error(&quot;This is error message.&quot;); } } log4j.properties#可以设置级别：debug&gt;info&gt;error #debug：显示debug、info、error #info：显示info、error #error：只error log4j.rootLogger=debug,appender1 #log4j.rootLogger=info,appender1 #log4j.rootLogger=error,appender1 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #样式为TTCCLayout log4j.appender.appender1.layout=org.apache.log4j.TTCCLayout]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j-配置模板]]></title>
    <url>%2F2016%2F05%2F21%2Flog4j-%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[输出为文本文件或HTML文件#设置级别： log4j.rootLogger=debug,appender1 #输出到文件(这里默认为追加方式) log4j.appender.appender1=org.apache.log4j.FileAppender #设置文件输出路径 #【1】文本文件 #log4j.appender.appender1.File=c:/Log4JDemo02.log #【2】HTML文件 log4j.appender.appender1.File=c:/Log4JDemo02.html #设置文件输出样式 #log4j.appender.appender1.layout=org.apache.log4j.TTCCLayout log4j.appender.appender1.layout=org.apache.log4j.HTMLLayout 输出为文本文件或HTML文件 多个目的地#设置级别和多个目的地 log4j.rootLogger=debug,appender1,appender2 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.TTCCLayout #输出到文件(这里默认为追加方式) log4j.appender.appender2=org.apache.log4j.FileAppender #设置文件输出路径 #【1】文本文件 #log4j.appender.appender2.File=c:/Log4JDemo02.log #【2】HTML文件 log4j.appender.appender2.File=c:/Log4JDemo02.html #设置文件输出样式 #log4j.appender.appender2.layout=org.apache.log4j.TTCCLayout log4j.appender.appender2.layout=org.apache.log4j.HTMLLayout SimpleLayout样式#设置级别和目的地 log4j.rootLogger=debug,appender1 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.SimpleLayout 输出DEBUG - This is debug message. INFO - This is info message. ERROR - This is error message. 自定义样式#设置级别和目的地 log4j.rootLogger=debug,appender1 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.PatternLayout #自定义样式 # %r 时间 0 # %t 方法名 main # %p 优先级 DEBUG/INFO/ERROR # %c 所属类的全名(包括包名) # %l 发生的位置，在某个类的某行 # %m 输出代码中指定的讯息，如log(message)中的message # %n 输出一个换行 log4j.appender.appender1.layout.ConversionPattern=%r [%t] [%p] - %c -%l -%m%n 输出0 [main] [DEBUG] - com.coderdream.log4j.HelloLog4j -com.coderdream.log4j.HelloLog4j.main(HelloLog4j.java:16) -This is debug message. 31 [main] [INFO] - com.coderdream.log4j.HelloLog4j -com.coderdream.log4j.HelloLog4j.main(HelloLog4j.java:18) -This is info message. 31 [main] [ERROR] - com.coderdream.log4j.HelloLog4j -com.coderdream.log4j.HelloLog4j.main(HelloLog4j.java:20) -This is error message. 多目的地、自定义样式#设置级别和目的地 log4j.rootLogger=debug,appender1,appender2 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.PatternLayout #自定义样式 # %r 时间 0 # %t 方法名 main # %p 优先级 DEBUG/INFO/ERROR # %c 所属类的全名(包括包名) # %l 发生的位置，在某个类的某行 # %m 输出代码中指定的讯息，如log(message)中的message # %n 输出一个换行符号 log4j.appender.appender1.layout.ConversionPattern=[%d{yy/MM/dd HH:mm:ss:SSS}][%C-%M] %m%n #输出到文件(这里默认为追加方式) log4j.appender.appender2=org.apache.log4j.FileAppender #设置文件输出路径 #【1】文本文件 log4j.appender.appender2.File=c:/Log4JDemo06.log #设置文件输出样式 log4j.appender.appender2.layout=org.apache.log4j.PatternLayout log4j.appender.appender2.layout.ConversionPattern=[%d{HH:mm:ss:SSS}][%C-%M] -%m%n 设置 特定包的级别和目的地[企业应用]#省略根，只设置特定包的级别和目的地 log4j.logger.com.coderdream.log4j=debug,appender1 log4j.logger.com.coderdream.log4jDao=info,appender1,appender2 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.PatternLayout #自定义样式 # %r 时间 0 # %t 方法名 main # %p 优先级 DEBUG/INFO/ERROR # %c 所属类的全名(包括包名) # %l 发生的位置，在某个类的某行 # %m 输出代码中指定的讯息，如log(message)中的message # %n 输出一个换行符号 log4j.appender.appender1.layout.ConversionPattern=[%d{yy/MM/dd HH:mm:ss:SSS}][%C-%M] %m%n #输出到文件(这里默认为追加方式) log4j.appender.appender2=org.apache.log4j.FileAppender #设置文件输出路径 #【1】文本文件 log4j.appender.appender2.File=c:/Log4JDemo07_Dao.log #设置文件输出样式 log4j.appender.appender2.layout=org.apache.log4j.PatternLayout log4j.appender.appender2.layout.ConversionPattern=[%d{HH:mm:ss:SSS}][%C-%M] -%m%n log4j.xml的配置方式&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt; &lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;appender1&quot; class=&quot;org.apache.log4j.RollingFileAppender&quot;&gt; &lt;param name=&quot;File&quot; value=&quot;logfile08.html&quot; /&gt; &lt;param name=&quot;MaxFileSize&quot; value=&quot;1MB&quot; /&gt; &lt;param name=&quot;MaxBackupIndex&quot; value=&quot;5&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.HTMLLayout&quot;&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;appender1&quot; /&gt; &lt;/root&gt; &lt;/log4j:configuration&gt; 为了提高效率，可以在写日志前增加判断：// 记录debug级别的信息 if (logger.isDebugEnabled()) { logger.debug(&quot;This is debug message from Dao.&quot;); } // 记录info级别的信息 if (logger.isInfoEnabled()) { logger.info(&quot;This is info message from Dao.&quot;); } // 记录error级别的信息 logger.error(&quot;This is error message from Dao.&quot;);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>代码模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人简历]]></title>
    <url>%2F2016%2F05%2F10%2F%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86%2F</url>
    <content type="text"><![CDATA[教育经历本科东华大学 (2011.09 - 2015.07) 专业： 软件工程 绩点 4.1 专业排名 2／60 获奖情况 东华大学奖学金 (2013、2014) 校三好学生 (2013、2014) 桑麻奖学 (2013) 东软奖学金 (2014) 上海市优秀毕业生 (2015) 硕士华东师范大学 (2015.09 - 2018.07) 专业： 软件工程 研究方向： 形式化方法、逆向工程 所属实验室：国家可信嵌入式软件工程研究中心 项目经历 MIPS 处理器多级流水线仿真 （2016.05） Intel 386 指令集反汇编引擎、中间代码生成工具（2016.03 - 2016.05） MIPS 指令集反汇编引擎（2016.03 - 2016.04） 360企业安全产品天擎6.0 （2014.11 - 2015.02） 实习经历奇虎360 （2014.11 - 2015.02） Java开发、PHP开发、前端开发 参与项目：企业安全产品天擎6.0 上海创多软件股份有限公司 （2014.07 - 2014.11） Java开发、前端开发 参与项目：在线英语阅读学习平台 To be continue…]]></content>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[翻译：MiniSAT用户指南]]></title>
    <url>%2F2016%2F04%2F03%2F%E7%BF%BB%E8%AF%91%EF%BC%9AMiniSAT%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[源网页MiniSAT User Guide: How to use the MiniSAT SAT Solver MiniSat是一个面向研究人员与开发人员所开发的微型、开源的布尔可满足性问题求解器(Boolean satisfiability problem solver)。它发布在 MIT license 下。 一个SAT求解器用于判断一个布尔表达式中的变量是否存在某个赋值能够使得该表达式取值为真。在这个表达式中，只能含有AND，OR，NOT，括号，以及布尔变量。如果可满足，大部分的 SAT 求解器（包括 MiniSAT）都会列出使该表达式为真的赋值。由于许多的问题都可以分解为一个大型的 SAT 问题（可能含有数千个变量），所以 SAT 求解器具有十分广泛的用途。 本文是一篇简单的 MiniSAT 用户指南。它描述了 MiniSAT 的使用方法，包括 它的输入格式、选项以及输出格式。 合取范式 （Conjunctive Normal Form）如众多 SAT 求解器一样，MiniSAT 要求的输入为合取范式。合取范式由以下构造块构成： 项（term）：一个项可以是一个布尔变量（比如： x4），也可以是一个布尔变量的非（NOT x4，在这里可以写成 -x4）。 子句（clause）：一个字句是一个或多个项的集合，通过 OR 运算符（在这里记为 |）连接；在一个子句中，相同的变量不会重复出现。 表达式（expression）：一个表达式有一个或多个子句组成，通过 AND 运算符（在这里记为 &amp;）进行连接。 一个 CNF 的示例： (x1 | x5 | x4) &amp; (-x1 | x5 | x3 | x4) &amp; (-x3 | x4). 任何布尔表达式都能转化为 CNF ；完成该工作的算法和代码能在别的地方获得。（比如： 可以参考 Russel 和 Norvig 在1995 年撰写的 “ Artificial Intelligence: A modern Approach “）。 MiniSAT 的输入格式 和大部分的 SAT 求解器一样， MiniSAT 所接受的输入是一种 DIMACS CNF 简化格式的文本。每一个以 c 字母开头的行都是注释。第一个非注释行必须是以下形式： p cnf NUMBER_OF_VARIABLES NUMBER_OF_CLAUSES 后续的每一个非注释行定义一个子句。每一行都是一个以空格分隔的变量列表；一个正值就是对应的变量 (4 就是 x4)，而一个负值就是那个变量的非（-5 就是 -x5）。每一行必须以一个空格和数字0 结尾。 因此以上的 CNF 表达式可以写成： c Here is a comment. p cnf 5 3 1 -5 4 0 -1 5 3 4 0 -3 -4 0 “ p cnf ” 这一行意思是这个 CNF 格式的 SAT 问题中，有 5 个变量以及 3 个子句。这一行之后的第一行就是第一个子句，也就是 x1 | -x5 | x4。 你可以把这看作是一个简单的表达式。或者你也可以把它看作为一个子句集合，而求解器的任务就是找到使所有子句为真的布尔变量赋值集合。 更多信息可以参考 SAT 2004 competition 调用 MiniSATMiniSAT 的用法如下： minisat [options] [INPUT-FILE [RESULT-OUTPUT-FILE]] INPUT-FILE 的格式为上述的 DIMACS CNF 格式，也可以是纯文本 或 gizp 压缩过的文件。你可以使用 -h 或者 –help 来查看其它的选项。 程序的选项包括： -pre = {none,once} [Turn on preprocessor] -asymm -rcheck -grow = NUM [ must be greater than 0 ] -polarity-mode = {true,false,rnd} -decay = NUM [ 0 - 1 ] -rnd-freq = NUM [ 0 - 1 ] -dimacs = OUTPUT-FILE -verbosity = {0,1,2} 带值的选项必须在中间加上 =，然后再是它的值，比如： minisat -pre=once 在许多问题中，使用预处理器是一个不错的想法（-pre=once）。 MiniSAT 输出格式当运行的时候，MiniSAT 向标准错误流发送一些执行的不同统计信息。根据表达式是否可满足，它会向标准输出流输出 SATISFIABLE 或者 UNSATIFIABLE （不包括引号）。 如果你指定了一个 RESULT-OUTPUT-FILE（结果输出文件），MiniSAT 会往这个文件中写入文本。如果可满足，第一行就会是 SAT，如果不可满足，第一行就会是 UNSAT 。如果是 SAT，第二行就会是满足表达式的布尔变量赋值集合。（尽管还有其他的，它只产生一个赋值）。 因此对于以上的例子，它会在输出文件中生成： SAT 1 2 -3 4 5 0 这意味着它是可满足的，在 x1=t, x2=t, x3=f, x4=t, 以及 x5=t 情况下（其中 t 是 true，f 是 false）。回到我们最初的例子，我们可以看到这确实是一个解： (x1 | -x5 | x4) = t | -t | t = t (-x1 | x5 | x3 | x4) = -t | t | f | t = t (-x3 | x4) = -f | t = t 获得更多的解如果你想要获得另一个解，“明显”的方式是将前一个解取非，作为一个新的子句添加到表达式中。比如，在我们的示例中，我们可以用 1 2 -3 4 5 0 来产生一个新的输入（注意：子句的数量增加了！）： p cnf 5 4 1 -5 4 0 -1 5 3 4 0 -3 -4 0 -1 -2 3 -4 -5 0 如果我们把这个放入文件 second.in 中，然后运行: minisat second.in second.out 我们可以得到一个新的解，以下是 second.out 内容： SAT 1 -2 -3 4 5 0 即： x1=t, x2=f, x3=f, x4=t, 以及 x5=t。这是和前一个不一样的解，因为 x2=f 而不是 x2=t。我们可以验证一下（和上一次一样，因为 x2 不在任何一个子句中）： (x1 | -x5 | x4) = t | -t | t = t (-x1 | x5 | x3 | x4) = -t | t | f | t = t (-x3 | x4) = -f | t = t 译者补充： MiniSAT 下载 与 编译以下操作均在 Ubuntu 终端环境下执行： 下载 minisat 源代码 wget http://minisat.se/downloads/minisat-2.2.0.tar.gz 解压缩 tar -xzf minisat-2.2.0.tar.gz 阅读 REDME 文件，查看相关信息 more README 内容如图： 内容描述了 minisat 的构建过程以及使用示例。 构建 minisat export MROOT= ~/minisat #设置系统环境变量 cd core #由于只需要核心功能，转到 core 目录 make rs #使用 make 进行编译 cp minisat_static ~/minisat/minisat #将生成的minisat_static 可执行文件复制到 `~/minisat` 目录下。 译者补充：MiniSAT 使用以下操作在之前编译的基础之上： 创建输入文件，内容如下： 执行命令 查看输出文件，内容如下：]]></content>
      <tags>
        <tag>MiniSAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[武术之于我]]></title>
    <url>%2F2016%2F03%2F16%2F%E6%AD%A6%E6%9C%AF%E4%B9%8B%E4%BA%8E%E6%88%91%2F</url>
    <content type="text"><![CDATA[不算双节棍的练习，从大三开始到研一上我就没有练习过武术。而实际上除了武术之外，其他所有的运动也都少了。 结果就是，差不多成了宅男，随之，脂肪开始染指肚皮，腹肌不再显现。对我而言，身形的变化并不是那么在意，而精神状态的变化才最让我开始紧张。 在经历过大四一年实习的折腾， 之后的日子，即使每天的工作只是在办公室玩玩电脑，看看书，也会深感疲惫，而加上晚上睡眠质量不高，次日就更加疲惫，于是，进入了恶性循环。身体素质每况愈下，而心理状态也未必能好到哪去，天天神思恍惚，有种混吃等死的感觉。所有的焦虑、紧张、负面思想随时涌上心头，再也无法压制或是转化，使得整个大脑的资源都被占用，变得疲于思考，丧失斗志。可以说，身体尚未彻底崩坏，而灵魂却快要被另一个人格取代。 这个学期，我觉得我再不做出改变，就完蛋了，这不是关乎自己未来前途，而是我本身这个人格的存亡。于是每天强制自己跳绳，俯卧撑以及腹肌训练，然后控制自己的睡眠时间，身体好像慢慢有力量充实了起来，不再腰酸背痛，晚上睡眠质量也很好，白天也不怎么会困。 而因为偶然，我发现了跆拳道社团的存在，经过简单了解，发现教练的来头不小，并且具有一定的权威，不只是简单的打打闹闹，因而便产生了加入训练的想法。而还未到跆拳道社团训练的时间，我收到了空手道社团的传单，一瞬间，脑子里想到了 腕力 和 豪力，那两只肌肉发达的宠物小精灵，觉得跆拳道练下半身，那么空手道就练上半身吧。 然后，在空手道课上，又知道了合气道，然后又进了合气道的圈。 现在…一周5天，每天两小时的训练，感觉还是很不错的。小朋友练一次酸一周，而我已经无所谓了。 练武术有一定年头，功夫上手没多少，但想法感悟还是有一些的。 关于实战意义我个人觉得，不论是传统武术，空手道，合气道还是跆拳道，对于现在的普通人，实战意义并不大，即使每一个都有实战的说法在，其中有些套路动作，也确实有实战的意味，但真的动手打架，招式都是散的，局面是千变万化、出乎意料的，靠的是体力，爆发力，抗打击能力，速度以及反应速度。一般的社团训练肯定是不够的。要想能实战对抗，必须要不断去真打，去受伤，屡败屡战才能快速提高。而对于普通人，社会还算安定，完全没有打架的需要，而打架解决问题往往是最不聪明的，也不能真正去解决问题。所以，武术又有了防身术的说法，也就是说，既然不能用于主动打人，那我关键时候防身，以免吃亏。这是很多武术流派知时势，懂进退的地方，而传统武术，有些人还是沉溺于过往的幻想，把传统武术捧高，以此证明身为习练者的价值，好像有一种有极高个人战斗力的优越感。然而个人之勇，血气之勇，早被枪炮打的稀碎。人本身是弱小的，在物理存在上极为弱小的，压根没有“排山倒海”，“斗转星移”，“凌波微步”，“九阳神功”，“降龙十八掌”之类的东西，也没有一招一式练到纯熟，就真能提高多少战斗力。到头来，武功再高，也怕菜刀，牛皮吹破，徒增笑柄。 我怎么看武术经常有人问我，我是因为什么原因去学习武术。我自己看来，一方面，很小的时候看电视，就喜欢武侠，那种恩怨分明，快意恩仇的侠客，（最主要大概还是英雄救美吧，哦，“侠之大者，为国为民” 才是政治正确，笑 ：) ）这可能是大多数人曾有的幻想，另一方面，读书早，个头、力气难免弱于同学，受过欺负，也就想反抗。好在我长的挺招人喜欢，心性还算单纯，少和人有冲突。所以，支撑我一直喜欢武术的，主要还是第一个原因。但是，我又说我破除了对武术的妄想，没有了实战的念头，那么现在，我为什么坚持学习这些东西？武术的意义，并不在于招式本身可用于实战，套路、招式是提炼于生活、劳动和战争的，是一种意境的抽取，真的练得好，一招一式都很有味道，而身体是自然的融入，不是刻意的伸张，也就是所谓的“道法自然”，就像金庸小说《天龙八部》里的扫地僧，成龙所演《少林寺》的烧饭伙夫。武术本身应该是对一种对身体的操练，它能使身体变得灵活，使身材变得优美，而最关键的，便是其中的意境融于己身，这是 “天人合一” 的真趣。譬如说，太极拳中每一个动作，都会有一个名字，“鞭”，“捶”，“炮”，它都是一种象征，一种将身体化为他物的想象，而借着这种想象，才能从招式间流露出所谓的感觉，鞭的抽打，锤的厚重，炮的刚猛无匹，那“白鹤亮翅”，“饿虎扑食”，“巨蟒吐丹”，当你想象自己是那一种动物时候，你会发现，那些动作的特点，很容易就能展现出来，“提气上扬”，“前扑下按”，“腰身婉转”，而身与心合，心与意合的体验，着实是让人喜悦的。我其实并没有正经练过多少，一开始也是看拳谱自练，但我去学拳，师傅都说有点味道。因为我会思考，这一招，它的目的是什么，它取自什么，模仿了什么。而其中原理，便是发力用劲的关键。形意拳中讲五行，“劈崩钻炮横”，对应“金木水火土”，而实际脱胎于兵器的使用，将手化为“刀剑锤枪炮”，其中手法转换，身形变化，闪转腾挪，知其原本，就得其意味，就算没有实用价值，也乐在其中。 有人觉得武术没用，一是过高的幻想，世上没有一劳永逸的事，要是这样，那么同样学的人，到底谁弱谁强呢，总有其他的因素会有所影响，二是没有明白其中真正的价值，盲目追求套路的繁复，动作的高难度，或者所谓的标准，从而丧失其中的趣味。所以，真正的读书人才是学武的好胚子，以往师父教的不只是拳，更多是做人，所以对得起“师父”二字。乡村野人，不知事理，可能有一身蛮力，也无法练就武学中的高等境界，至少，也难得其中趣味。我此次学三门武道，在别人看来，我是为了耍酷，装逼，去撩妹，而实际上，我更多的是以观察者的角度，去体会这些东西，包括其中的文化，其中的教学方法，其中的规矩，服从是因为我的尊重，并不意味我绝对的赞同，不然我也不会三门都学。当然，习练之时，认识朋友，交流观点，强身健体，也是为了更好的利用花下去的时间。当然，如果我能坚持下去，并且不耽误其他的事情，我觉得，这对我自身的能力的信心也会有极大的增强。 写这篇文章，一是想写点东西，留点存在感，二是听到空手道上有学弟嘲讽武术队套路的无用。而据我所知，跆拳道社团，社长是一个学妹，她就是不服武术课老师嘲讽了空手道而创建了社团。门派偏见，除了让人看不见他人的好，夜郎自大，并没有什么真正的价值。而偏见，岂止是门派呢。 致谢摄影卜祥兴 费凡 许赫]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的程序分析优化技术]]></title>
    <url>%2F2016%2F03%2F13%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[常见的程序分析优化技术常量折叠（Constant Folding）在编译时识别代码中的常量表达式，并对之求值，而不是留在运行时再进行求值。例如 i = 320 * 200 * 32; 现代编译器不会真的为这条语句生成两个乘法指令以及一个存储指令，而是在编译时进行求值（2,048,000），然后用这个值直接进行替换。而在 0*x 语句中，即使编译器不知道 x 变量的值，它也能用 0 对表达式进行替换 而常量折叠也不仅仅能够在数值计算中使用，也能在字符串连接运算中使用。 &quot;abc&quot;+ &quot;def&quot; 会被替换为 &quot;abcdef&quot; 常量折叠可以在编译器前端高级语言的中间表示树期间，也就是在翻译成三地址指令之前完成，或者在编译器后端作为常量传播的辅助。 注意: 存在交叉编译的情况，这时候需要考虑在不同的架构中，浮点数的精度存在差异，盲目进行常量折叠可能导致宿主机于目标主机的算术计算不一致的情况。 常量传播（Constant Propagation）常量传递是在编译期间用常量的值替换代码表达式中常量的过程。 int x =14; int y = 7 - x / 2; return y * (28 / x + 2); 传递 x 后： int x = 14; int y = 7 - 14 / 2; return y * (28/x + 2); 继续传递 y 后： int x = 14; int y = 0; return 0; （未完待续）]]></content>
      <categories>
        <category>程序分析</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[反直觉的“三门问题”]]></title>
    <url>%2F2015%2F10%2F24%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[“三门问题”是什么三门问题，又称为“蒙提霍尔问题”、“蒙提霍尔悖论”。 这个问题出自一个美国电视节目Let’s make a deal。而其名字则来自于节目主持人蒙提霍尔(Monty Hall problem)的名字。 在电视节目中，参与者的面前有三扇门，其中一扇门背后是汽车，另外两扇门背后是山羊。 参与者只能选择打开其中一扇门，如果门背后的是汽车，那么参与者就可以得到它，如果是羊，那么什么都不会得到。 然而，在参与者做出选择后，主持人已知三扇门后藏了什么的情况下，打开另外两扇门中的其中一扇，背后的是一只羊。 随后，主持人问参赛者，要不要改变选择，去选另一扇门。 问题关键那么问题就是：有没有必要去更改选择？选择另一扇门是否更有利？ 错误的直觉有的人可能会想：换不换选择，选中的可能性都为三分之一，意义不大。 还有的人认为：在主持人剔除一个选择后，更换选择后，抽中的概率从三分之一上升为 二分之一。这种思维很诡异，如果说概率提高了，那应该是两个剩余的选项都提高，那么其实剩余两扇门抽中汽车的概率应该是相等的，换不换依旧是没有意义的。 那么到底改不改换神秘主义的人可能会这么想 反正换不换都一样，不如换着试试，指不定真中了呢。 阴谋论的人大概会这么想 不对！你这么说，肯定想唬我，不想让我得到那辆车…坚决不换！ 天秤座则陷入痛苦不堪的选择的简谐振动之中 换？不换？换？不换…啊啊啊，到底选哪个好，好纠结。 “政治”正确的做法当然是换，我们不能以小人之心度君子之腹，主持人这么做，必有深意。换一换，得之我命，失之也就一句“我X”的事。赌一把吧。 好吧，严肃点，不开玩笑了。我们做一个选择，必须还是要理性，虽然随机的貌似更有趣，但面对人生大事的时候可不能马虎啊。 解法一（枚举法）：1. 假如汽车在第一次选择的门背后，那么第二次 a. 选择不换，那么必能得到汽车，中奖概率为 1 b. 选择换，那么必不能得到汽车，中奖概率为 0 2. 假如汽车不在第一次选择的门背后，那么第二次 a. 选择不换，那么必不能得到汽车，中奖概率为 0 b. 选择换，那么必能得到汽车，中奖概率为 1 综合计算下，第二次变更选择的情况下，中奖概率是多少： 第一种情况下概率： 1/3 * 0 = 0 第二种情况下概率： 2/3 * 1 = 2/3 综合概率： 0 + 2/3 = 2/3 显然，不换的情况下，我们中奖的概率在第一次就决定了，为 三分之一，而如果修改选择，我们中奖的概率则提升到了 三分之二 ，当然选择换。 ⊙▂⊙，枚举法是不是太蠢了点。如果给一百扇门让我选，我当时就要吓懵比了。当然，其实并不会。那么有没有更直观的方法呢。 解法二：我们可以知道，三扇门每扇门背后是汽车的概率都是 三分之一 。 那么在我们选出一扇门后，这扇门的中奖概率为 三分之一 ，另外两扇门的中奖概率之和就是 三分之二 。 在主持人帮我们剔除其中一个错误选择后， 则相当于： 原来 三分之二 的概率 被剩下的一扇门 “继承” 了。 聪明的我们当然应该 改选 这扇更有 “前途” 的门。 “ WHAT？!发生了什么。什么叫继承了概率？什么鬼？！ ” 其实可以这么理解： 我们第一次选择时，如果选择另外的两扇门的组合，则获奖概率是 三分之二，然而规则是不允许我们选两扇门的。 正当我们纠结的时候，善解人意的主持人很配合地为我们剔除了其中一个不会中奖的选项，那么我们就能选那个 “组合” 了，(哦，卖狗的，天上掉馅饼了！ 那两个门突然合并成了一个门了！)，那么剩下的那扇门代表的是依然是 三分之二 的中奖概率。 继承到底是怎么回事？如果原来是 n 扇门的话，那么，第一次选择的门中奖概率为 1 / n , 而剩下门中奖概率之和则为 (n-1) / n。 主持人帮我们消除其中一扇门之后，中奖概率应该怎么继承？当然应该由剩下的 n-2 门均分，那么剩下的每扇门的中奖概率变成了 ((n-1) / n) / (n-2) 。 那么，剩余的 n-2 扇门的中奖概率提升为原来的 (n-1) / (n-2)倍了，即 1 + 1 / (n-2)。 这么看来，三扇门的问题只是其中一个具体问题。将 n=3 代入，则剩下的 一(3-2) 扇门的概率上升为原来的 两倍(1 + 1 / (3-2))倍了，这个时候，谁不换谁傻。 总结这个问题关键在于，主持人是知道门背后藏有什么的。 我们可以理解为，当一个随机系统引入了一个不随机的因素，整个系统就不能单纯当作随机系统来看了。 所以换不换，是要仔细思考的问题。2B or not 2B , that’s a question ! 嗯，做人要有理想，但还需要根据现实情况来改变自己的理想，不能一味地盲目坚持。]]></content>
      <categories>
        <category>概率统计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[中国计算机学会推荐国际学术刊物（计算机科学理论）]]></title>
    <url>%2F2015%2F09%2F11%2F%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E5%88%8A%E7%89%A9%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%90%86%E8%AE%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[A类 序号 刊物简称 刊物全称 出版社 网址 1 IANDC Information and Computation Elsevier http://www.journals.elsevier.com/information-and-computation/ 2 SICOMP SIAM Journal on Computing SIAM http://epubs.siam.org/journal/smjcat B类 序号 刊物简称 刊物全称 出版社 网址 1 TALG ACM Transactions on Algorithms ACM http://talg.acm.org/ 2 TOCL ACM Transactions on Computational Logic ACM http://tocl.acm.org/ 3 TOMS ACM Transactions on Mathematical Software ACM http://toms.acm.org/ 4 Algorithmica Springer http://www.springerlink.com/content/100117/ 5 Computational complexity Springer http://www.springer.com/birkhauser/computer+science/journa 7 Formal Methods in System Design Springer http://www.springerlink.com/content/1572-8102/ 8 INFORMS Journal on Computing INFORMS http://www.informs.org/Pubs/IJOC 9 JCSS Journal of Computer and System Sciences Elsevier http://www.journals.elsevier.com/journal-of-computer-and-system-sciences/ 10 JGO Journal of Global Optimization Springer http://link.springer.com/journal/10898 11 Journal of Symbolic Computation Elsevier http://www.elsevier.com/wps/find/journaldescription.cws_home/622902/description 12 MSCS Mathematical Structures in Computer Science Cambridge University Press http://journals.cambridge.org/action/displayJournal?jid=MSC 13 TCS Theoretical Computer Science Elsevier http://www.journals.elsevier.com/theoretical-computer-science/ C类 序号 刊物简称 刊物全称 出版社 网址 1 Annals of Pure and Applied Logic Elsevierc http://www.sciencedirect.com/science/journal/01680072 2 Acta Informatica Springer http://www.springerlink.com/content/100460/ 3 Discrete Applied Mathematics Elsevier http://www.elsevier.com/wps/find/journaldescription.cws_home/505609/description 4 Fundamenta Informaticae IOS Press http://fi.mimuw.edu.pl/index.php/FI/index 5 Higher-Order and Symbolic Computation Springer http://springerlink.metapress.com/content/1573-0557/ 6 Information Processing Letters Elsevier http://www.journals.elsevier.com/information-processing-letters/# 7 JCOMPLEXITY Journal of Complexity Elsevier http://www.journals.elsevier.com/journal-of-complexity/ 8 LOGCOM Journal of Logic and Computation Oxford University Press http://logcom.oxfordjournals.org/ 9 Journal of Symbolic Logic Association for Symbolic Logic http://www.aslonline.org/journals-journal.html 10 LMCS Logical Methods in Computer Science LMCS http://www.lmcs-online.org/index.php 11 SIDMA SIAM Journal on Discrete Mathematics SIAM http://www.siam.org/journals/sidma.php 12 Theory of Computing Systems Springer http://www.springerlink.com/content/1433-0490/]]></content>
      <categories>
        <category>计算机科学理论</category>
      </categories>
      <tags>
        <tag>学术论文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql常用命令]]></title>
    <url>%2F2015%2F08%2F07%2Fmysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、连接Mysql格式: mysql -h主机地址 -u用户名 －p用户密码 用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码 连接本机上的mysql 键入命令 mysql -u root -p 回车后提示你输密码 连接到远程主机上的MYSQL 假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令： mysql -h110.110.110.110 -u root -pabcd123 二、修改密码格式 mysqladmin -u用户名 -p旧密码 password 新密码 给root加个密码ab12 mysqladmin -u root -password ab12 因为开始时root没有密码，所以-p旧密码一项就可以省略了。 再将root的密码改为djg345 mysqladmin -u root -p ab12 password djg345 三、增加新用户格式 grant select on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot; 增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令： grant select,insert,update,delete on *.* to test1@&quot;%&quot; Identified by &quot;abc&quot;; 增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机） grant select,insert,update,delete on mydb.* to test2@localhost identified by &quot;abc&quot;; 如果你不想test2有密码，可以再打一个命令将密码消掉。 grant select,insert,update,delete on mydb.* to test2@localhost identified by &quot;&quot;; 四、相关信息查看显示当前数据库服务器中的数据库列表mysql&gt; SHOW DATABASES; 注意：mysql库里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。 显示数据库中的数据表mysql&gt; USE 库名； mysql&gt; SHOW TABLES; 显示数据表的结构mysql&gt; DESCRIBE 表名; 显示use的数据库名mysql&gt; SELECT DATABASE(); 显示当前的usermysql&gt; SELECT USER(); 五、数据库操作建立数据库mysql&gt; CREATE DATABASE 库名; 建立数据表mysql&gt; USE 库名; mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1)); 删除数据库mysql&gt; DROP DATABASE 库名; 删除数据表mysql&gt; DROP TABLE 表名； 将表中记录清空mysql&gt; DELETE FROM 表名; 显示表中的记录mysql&gt; SELECT * FROM 表名; 往表中插入记录mysql&gt; INSERT INTO 表名 VALUES (&quot;hyq&quot;,&quot;M&quot;); 更新表中数据mysql-&gt; UPDATE 表名 SET 字段名1=&apos;a&apos;,字段名2=&apos;b&apos; WHERE 字段名3=&apos;c&apos;; 用文本方式将数据装入数据表中mysql&gt; LOAD DATA LOCAL INFILE &quot;D:/mysql.txt&quot; INTO TABLE 表名; 导入.sql文件命令mysql&gt; USE 数据库名; mysql&gt; SOURCE d:/mysql.sql; 命令行修改root密码mysql&gt; UPDATE mysql.user SET password=PASSWORD(&apos;新密码&apos;) WHERE User=&apos;root&apos;; mysql&gt; FLUSH PRIVILEGES; 六、一个建库和建表以及插入数据的实例drop database if exists school; //如果存在SCHOOL则删除 create database school; //建立库SCHOOL use school; //打开库SCHOOL create table teacher //建立表TEACHER ( id int(3) auto_increment not null primary key, name char(10) not null, address varchar(50) default &apos;深圳&apos;, year date ); //建表结束 //以下为插入字段 insert into teacher values(&apos;&apos;,&apos;allen&apos;,&apos;大连一中&apos;,&apos;1976-10-10&apos;); insert into teacher values(&apos;&apos;,&apos;jack&apos;,&apos;大连二中&apos;,&apos;1975-12-23&apos;); 如果你在mysql提示符键入上面的命令也可以，但不方便调试。 你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\下，并在DOS状态进入目录\mysql\bin，然后键入以下命令： mysql -uroot -p密码 &lt; c:\\school.sql 如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。 或者进入命令行后使用 mysql&gt; source c:\\school.sql; 也可以将school.sql文件导入数据库中。 将文本数据转到数据库中 文本数据应符合的格式：字段数据之间用tab键隔开，null值用\n来代替.例： 3 rose 大连二中 1976-10-10 4 mike 大连一中 1975-12-23 假设你把这两组数据存为school.txt文件，放在c盘根目录下。 数据传入命令 load data local infile &quot;c:\\school.txt&quot; into table 表名; 注意：你最好将文件复制到\mysql\bin目录下，并且要先用use命令打表所在的库。 备份数据库导出整个数据库导出文件默认是存在mysql\bin目录下 mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名 mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql 导出一个表mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql 导出一个数据库结构mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 带语言参数导出mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql 备份数据库mysqldump -uroot -p test_db &gt; test_db.sql 恢复数据库mysql -uroot -p test_db &lt; test_db.sql 创建权限grant all privileges on test_db.* to test_db@&apos;localhost&apos; identified by &apos;123456&apos;; 兼容mysql4.1之前模式： update mysql.user set password=old_password(&apos;123456&apos;) where user=&apos;test_db&apos;; 忘记密码在 “my.cnf“ 或 “my.ini“ 文件的 “mysqld“ 配置段添加 “skip-grant-tables“ ，然后重新启动 mysql 即可登录修改 root 密码。]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python计时工具:timeit]]></title>
    <url>%2F2015%2F08%2F05%2Fpython%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[有时候，我们写了一个小程序，自我感觉良好。通常这个时候就会想要测试一下运行的效率。最基本的，就是测量程序的运行时间。 常规方法通常我们会这么做： 将程序代码封装在一个函数中，然后再主函数中调用它 在函数调用前打一个时间戳 t1 在函数调用后打一个时间戳 t2 最后，计算两个时间戳的差值 t2 - t1 输出时间差 利用time模块（不推荐）。time.localtime(), time.time(), time.clock() 对比： time.localtime()，localtime返回的是struct_time，包含年月日，显然没有必要，更重要的是localtime()的精度依赖于time() time.time()，time返回的是UTC时间（seconds since the 00:00:00 UTC on January 1）。在很多系统，包括windows下精度很差，win32下的精度只有1/18.2秒。不过在Unix/Linux系统下，time()的精度还是很高的。 Python的标准库手册推荐在任何系统下都尽量使用time.clock()。不过要注意是在win32系统下，这个函数返回的是真实时间（wall time），而在Unix/Linux下返回的是CPU时间。在win32下，这个函数的时间分辨率好于1微秒。 代码示例# -*- coding: utf-8 -*- #!/bin/env python def test(): L=[] for i in range(100): L.append(i) if __name__==&apos;__main__&apos;: from time import clock start=clock() for i in range(10000): test() finish=clock() print (finish-start)/10000 执行结果为0.00032365431221 这样倒是没什么问题，但有时候就比较麻烦，比如想要测试多次，就需要再套一层循环。 而在 python 中，提供了一个名为 timeit 的计时工具。 timeit模块Timertimeit 模块定义了一个 Timer类。该类接收两个参数。 第一个参数，是你要计时的语句和函数； 第二个参数，是为第一个参数语句构建环境的导入语句 创建 Timer 类后，即可调用 timeit 方法进行计时。 接受一个参数作为被计时语句的调用次数，默认为一百万次 返回所耗费的秒数 另一个可以调用的方法为 repeat 。 接收两个参数。第一个参数为整个测试试验的次数，第二个参数为测试的次数。 返回每次试验的结果 代码示例# -*- coding: utf-8 -*- #!/bin/env python def test1(): n=0 for i in range(101): n+=i return n def test2(): return sum(range(101)) def test3(): return sum(x for x in range(101)) if __name__==&apos;__main__&apos;: from timeit import Timer t1=Timer(&quot;test1()&quot;,&quot;from __main__ import test1&quot;) t2=Timer(&quot;test2()&quot;,&quot;from __main__ import test2&quot;) t3=Timer(&quot;test3()&quot;,&quot;from __main__ import test3&quot;) print t1.timeit(10000) print t2.timeit(10000) print t3.timeit(10000) print t1.repeat(3,10000) print t2.repeat(3,10000) print t3.repeat(3,10000) 结果如下3.21831489756 0.109082858296 4.83077821343 [3.2328774327463403, 3.200496361967792, 3.219513164382626] [0.11024445844373787, 0.10911708052280389, 0.10891761383080834] [4.817947811802895, 4.892466221265554, 5.003930946530911]]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一小时掌握sqlite]]></title>
    <url>%2F2015%2F08%2F03%2F%E4%B8%80%E5%B0%8F%E6%97%B6%E6%8E%8C%E6%8F%A1sqlite%2F</url>
    <content type="text"><![CDATA[sqlite是什么SQLite 是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。 与其他数据库管理系统不同，SQLite 的安装和运行非常简单，在大多数情况下 - 只要确保SQLite的二进制文件存在即可开始创建、连接和使用数据库。即不用额外安装数据库软件即可使用数据。 如果您正在寻找一个嵌入式数据库项目或解决方案，SQLite是绝对值得考虑。 sqlite安装windows 环境 进入下载页面 ，下载windows预编译 (Precompiled Binaries for Windows) 的二进制文件包。 sqlite-shell-win32-x86-&lt;build#&gt;.zip sqlite-dll-win32-x86-&lt;build#&gt;.zip 注意: &lt;build#&gt; 是 sqlite 的编译版本号 将 zip 文件解压到你的磁盘，并将解压后的目录添加到系统的 PATH 变量中，以方便在命令行中执行 sqlite 命令。 可选: 如果你计划发布基于 sqlite 数据库的应用程序，你还需要下载源码 (Source Code) 以便编译和利用其 API sqlite-amalgamation-&lt;build#&gt;.zip Linux 环境 Debian 或 Ubuntu环境下 /* For Debian or Ubuntu /* $ sudo apt-get install sqlite3 sqlite3-dev RedHat, CentOS, or Fedora /* For RedHat, CentOS, or Fedora/* $ yum install SQLite3 sqlite3-dev Mac OX 环境雪豹或者更新版本系统中已经自带 开始操作创建数据库sqlite3 test.db 创建数据表sqlite&gt; create table user (id integer primary key, name text, age integer); 表名user 三个字段 id, name, age id 为 主键 注意：至少创建一个表或视图，否则数据库不能被保存到磁盘中。 往数据表中插入数据sqlite&gt; insert into user(id, name, age) values(1, &apos;Micheal&apos;, 20); sqlite&gt; insert into user(id, name, age) values(2, &apos;Jenny&apos;, 22); sqlite&gt; insert into user(name, age) values(&apos;Bob&apos;, 19); sqlite&gt; insert into user(name, age) values(&apos;Kerk&apos;, 20); 查询数据sqlite&gt; select * from user; 设置格式化查询结果sqlite&gt; .mode column; sqlite&gt; .header on; sqlite&gt; select * from user; .mode column 将设置为列显示模式 .header 将显示列名。 修改表结构增加列sqlite&gt; alter table user add column email text not null default &apos;&apos; collate nocase; 显示表结构sqlite&gt; .schema user 创建视图sqlite&gt; create view nameview as select id,name from user; 取 user 表的 id,name 两列创建视图 创建索引sqlite&gt; create index test_idx on user(name); 为 user 表的 name 列创建索引 获取所有表和视图sqlite&gt; .tables 获取指定表的索引列表sqlite&gt; .indices user 数据库导出sqlite&gt; .output test.sql sqlite&gt; .dump sqlite&gt; .output stdout .ouput 命令将输出重定向到文件，导出后，将输出重定向回控制台( stdout ) 从 sql 文件导入数据库sqlite&gt; .read test.sql 格式化输出数据到 CSV 格式sqlite&gt; .output test.csv sqlite&gt; .separator , sqlite&gt; select * from test; sqlite&gt; .output stdout 从 CSV 文件导入数据到表中sqlite&gt; create table newtable ( id integer primary key, value text ); sqlite&gt; .import [filename.csv ] newtable 备份数据库/* usage: sqlite3 [database] .dump &gt; [filename] */ sqlite3 test.db .dump &gt; backup.sql 恢复数据库/* usage: sqlite3 [database ] &lt; [filename ] */ sqlite3 mytable.db &lt; backup.sql]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim学习笔记]]></title>
    <url>%2F2015%2F07%2F26%2FVim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[vim 是从 vi 发展出来的一个文本编辑器，在程序猿中被广泛使用。和Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。 入门Vim的模式Vim 和 vi 一样，仅仅通过键盘来在这些模式之中切换。这就使得 Vim 可以不用进行菜单或者鼠标操作，并且最小化组合键的操作。对文字录入员或者程序员可以大大增强速度和效率。 Vim具有6种基本模式： 普通模式(Normal mode) 在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。 Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个&quot;d&quot;的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的&quot;j&quot;键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。 在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。 插入模式(Insert mode) 在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。 在插入模式中，可以按ESC键回到普通模式。 可视模式(Visual mode) 这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的&quot;文本对象&quot;也能和移动命令一样用在这个模式中。 选择模式(Select mode) 这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。 命令行模式(Command line mode) 在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。 Ex模式(Ex mode) 这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。 这其中我们常用到就是普通模式、插入模式和命令行模式，本课程也只涉及这三个常用模式的内容 三种常用模式 普通模式 插入模式 命令行模式 vim 启动时即进入**普通模式**，在__普通模式__中，按 `i`（插入）或 `a`（附加）键都可以进入**插入模式**，普通模式中，按 `:` 进入命令行模式。命令行模式中输入 `wq` 回车后保存并退出 vim。 vim的常用操作普通模式：光标移动： h, j, k, l 或使用方向键 可以移动光标。 w, b 分别为移动到 下一个/上一个 单词 退出： Shift+zz 保存退出 vim 删除文本： x 删除游标所在的字符 X 删除游标所在前一个字符 Delete 同 x dd 删除整行 dw 删除一个单词（不适用中文） d$ 或 D 删除至行尾 d^ 删除至行首 dG 删除到文档结尾处 d1G 删至文档首部 除此之外，你还可以在命令之前加上数字，表示一次删除多行，如： 2dd表示一次删除2行 插入模式:命令行模式 进入 插入模式： i 光标处进行编辑 I 行首插入 A 行末插入 a 光标后编辑 o 光标后插入新行 O 光标前插入新行 cw 替换从光标所在位置后到一个单词结尾的字符 命令行模式：退出： w 回车，保存文档 w 文件路径 另存为 saveas 文件路径 另存为 q! 强制退出 q 退出 wq! 强制保存并退出 x 保存并退出 wq 保存并退出]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具 教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java图形界面编程（Swing可拔插外观样式）]]></title>
    <url>%2F2015%2F07%2F24%2FJava%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8F%AF%E6%8B%94%E6%8F%92%E5%A4%96%E8%A7%82%E6%A0%B7%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Swing可拔插式外观样式相比于 AWT ，Swing 具有一个重要的优势—— 允许开发者定制组件的外观样式。而 AWT 则只能使用底层操作系统提供的组件外观样式。 Swing 的这个特性为美化程序外观样式提供了足够的灵活性。 该特性被称为 可拔插式外观样式（pluggable look-and-feel，PLAF） 提示：可以参考QQ的皮肤切换功能。 而且，Swing 默认提供了一些外观样式供开发者使用。其中，“metal” 是默认使用的样式，而 “nimbus” 是Java7新增的样式。 除了不同平台上相同的外观样式，不同平台上还有特定的外观样式。 程序的外观样式由 javax.swing.UIMangager 类管理。UIManager 类可以为程序切换不同的外观样式。 示例代码import javax.swing.*; import java.awt.*; import java.awt.event.ItemEvent; import java.awt.event.ItemListener; /** * PLAF(Pluggable look and feel) * Created by jiawen on 2015/7/24. */ public class Plaf { public void selectPlaf() { final JFrame frame = new JFrame(); //获得系统自带的所有外观样式信息 UIManager.LookAndFeelInfo[] lafs = UIManager.getInstalledLookAndFeels(); JComboBox combo = new JComboBox(lafs); combo.addItemListener(new ItemListener() { @Override public void itemStateChanged(ItemEvent e) { if (e.SELECTED == e.getStateChange()) { //如果状态改变为选中，则... UIManager.LookAndFeelInfo info = (UIManager.LookAndFeelInfo) e.getItem(); try { //设置新的外观样式 UIManager.setLookAndFeel(info.getClassName()); //更新界面 SwingUtilities.updateComponentTreeUI(frame); } catch (ClassNotFoundException e1) { e1.printStackTrace(); } catch (InstantiationException e1) { e1.printStackTrace(); } catch (IllegalAccessException e1) { e1.printStackTrace(); } catch (UnsupportedLookAndFeelException e1) { e1.printStackTrace(); } } } }); frame.add(combo, BorderLayout.NORTH); frame.add(new JButton(&quot;按钮&quot;), BorderLayout.SOUTH); frame.setTitle(&quot;可拔插外观样式示例&quot;); frame.setSize(600, 300); frame.setVisible(true); frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new Plaf().selectPlaf(); } } 运行效果外观样式选择下拉框 默认外观样式 nimbus外观样式]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 图形界面编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS主机搭建VPN]]></title>
    <url>%2F2015%2F05%2F28%2FVPS%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BAVPN%2F</url>
    <content type="text"><![CDATA[概述当你拥有一台国外的VPS的时候，你就可以用来搭建VPN，然后就能翻墙了（翻墙你都不知道的话，先去百度下吧）。PS：写完我才发现，一般人还是看不懂的。 搭建VPN的主要分为两个步骤： 安装pptpd，并配置 安装iptables,配置iptables 名词解释pptpd:pptp全称（Point to Point Tunneling Protocol），点对点隧道协议。是一种支持多协议虚拟专用网络技术[1]。就是利用它来实现的VPN功能。 iptables:iptables 是linux系统下的应用层防火墙工具。我们用它主要用来控制网络信息的转发，使服务器能够起到代理作用，可以理解为跳板吧。同时，可以用来限制访问。 系统环境操作系统：Ubuntu14.04 x86 准备远程登陆系统，进入shell,此时一般已经为root用户。 pptpd安装与配置安装输入命令 apt-get install pptpd 配置编辑配置文件 vi /etc/pptpd.conf 找到并修改ip这里假设你的VPS的IP地址为：138.128.193.121 localip 138.128.193.121 remoteip 138.128.193.121-254,138.128.193.1 如图 设置DNS 打开文件 vi /etc/ppp/pptpd-options 修改DNS为google的DNS ms-dns 8.8.8.8 ms-dns 8.8.4.4 设置账号（此处的账号就是你将来用来登陆VPN的账号）： vi /etc/ppp/chap-secrets 添加一行，依次为：用户名，服务，密码，限制IP xiongvpn pptpd passwd123 * ... 星号表示，不限制ip，因为你以后用的时候，自己设备的ip可能有变化，所以这里不设限制。此处可以设置多行，也就是可以设置许多的账户。弄个自动修改的机制的话，就可以在线卖VPN了。 重启服务： /etc/init.d/pptpd restart 设置IP转发: 打开文件 vi /ect/sysctl.conf 去掉文件中一行前的注释符号# net.ipv4.ip_forward=1 使它立刻生效 sysctl -p iptables安装与配置安装apt-get install iptables 配置假设你的VPS的IP地址为：138.128.193.121 建立一个NAT(Network Address Translation，网络地址转换): iptables -t nat -A POSTROUTING -s 138.128.193.0/24 -o eth0 -j MASQUERADE 设置MTU，防止包过大： iptables -A FORWARD -s 138.128.193.0/24 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1200 将规则保存，使重启后规则不丢失： iptables-save &gt;/etc/iptables-rules 编辑网卡文件，加载网卡时自动加载规则 vi /etc/network/interfaces 末尾加入： pre-up iptables-restore &lt;/etc/iptables-rules 检查pptp默认1723端口是否监听中：netstat -anlp |grep :1723 VPN的使用可以参考百度经验_浙江大学VPN设置方法-WIN7 主要会用到的信息： VPS的IP地址 之前在chap-secrets文件中添加的用户名与密码。 参考[1] 百度百科_PPTP [2] 如何在Ubuntu下配置pptp vpn]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具 科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建一个一年只需4美元的VPN]]></title>
    <url>%2F2015%2F05%2F26%2F%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%80%E5%B9%B4%E5%8F%AA%E9%9C%804%E7%BE%8E%E5%88%80%E7%9A%84VPN%EF%BC%88%E6%90%9E%E6%9C%BA%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述今天教大家怎么搭建一个一年只需要4刀的VPN服务器。大家只需照做，就可以建立一个属于自己的VPN服务器，然后通过VPN登录，就可以访问国外的网络，虽然速度有时候不太稳定，但对于查询资料，或是上FB，twitter而言足够。另外，这里搭建的VPN服务器，所有的设备都可以登录使用，无论是电脑还是手机，并且无需安装额外的软件。我的选择的服务器在美国西海岸洛杉矶机房，是四个可选机房中最快的一个，个人使用下来，一般白天比较快，进网页，google什么的很流畅，晚上使用的话就可能会慢的不行。我猜想是因为时差的原因，这边白天刚好网络情况比较好。 声明：希望大家做一个理性的人，好好利用VPN进行科学上网，不要做违反国家法律法规的事情。 通常，搭建VPN服务器，主要分为以下几个步骤： 租借一台中国可以访问的国外的VPS 安装Linux操作系统 安装pptpd，配置pptpd 安装iptables，配置iptables 主要名词解释VPNVPN全称Virtual Private Network，即虚拟专用网络。主要作用是在公用网络上建立专用网络，进行加密通讯。VPN可通过服务器、硬件、软件等多种方式实现[1]。 VPSVPS全称Virtual Private Server，即虚拟专用服务器。使用虚拟化技术，可以将一台物理服务器划分为多个虚拟服务器[2]。 通俗的说，就是利用软件对一台服务器的资源（硬盘空间、内存空间、计算能力、网络带宽等）进行分割，划分成多个虚拟的服务器来进行使用。 类似于房东将一个大房子分隔成多个小房间，然后出租给多个租户。 搭建步骤租借国外VPSVPS的价格各不相同。厂商不同，所提供的VPS质量各不相同，价格也不相同。相同厂商的VPS的价格，通常与VPS的硬件配置与网络资源（内存大小、硬盘大小、CPU核心数量、带宽大小、流量等）相关。配置越高，拥有的网络资源越多，价格就越高。 我们搭建VPN服务器所需要的配置并不高，然而市场上的VPS通常为中小企业网站提供，最低的配置对我们而言都过剩了，价格也相对比较贵，通常几美元至几十美元每月。 我们所要使用的4美元/年的VPS，是bandwagonhost(搬瓦工)提供的微型VPS。直接上这个厂商的官方网站，你可能找不到我们所需要的名为Micro-64的微型VPS（首页上找不到的O(∩_∩)O）所以我提供一个超链接，方便你找到它[Micro-64]，位于页面中间位置偏上一点点，或者你直接按Ctrl+F调出浏览器搜索，搜Micro-64直接定位。 该Micro-64 vps的配置为： HDD: 1.5 GB 机械硬盘空间： 1.5GB RAM: 64 MB 内存大小： 64MB CPU: 1x Intel Xeon BW: 100 GB/mo： 流量：100GB/月 价格： $3.99 USD/年 虽然看上去配置很低，但对于只需要跑几个软件程序的VPN服务器而言已经足够了。访问国外网站速度的瓶颈关键在于当前网络连接的拥塞情况。这个有时候也是没办法的事情，网络质量高的VPS价格也非常贵，所幸，这个VPS还是挺好用的。当然，也有配置稍微高一点，流量大一点的Micro-96、Micro-128。其实，以我们的网速及使用频率，100GB/月够用了，我用半个多月了，才用了不到5GB不到，还是开着更新了好多的软件。 其实这个VPS就是全文关键啦，用来搭建VPN比较经济实惠，会搭的人就可以散了。 购买步骤： 官网注册个账号（这里有个比较郁闷的问题是，注册的时候验证码的生成与google有点关系，所以需要翻墙才能显示出来…呵呵） 然后再点击之前的那个购物车，找到Micro-64，然后点击Order Now下单。 接下来跳转至了Product Configuraton页面，因为默认地点就是洛杉矶，不用修改，直接点Add to Cart按钮。 接下来是Order Summary,如果没有别的要买了，就Check out。 接下来就是Check out页面啦，也就是确认一下你的具体信息什么的，然后就可以支付了。 注意：需要用`Paypal`支付，没有的话就去注册个。一开始我以为必须要用信用卡，后来发现普通银联卡也可以绑定。 付完款后，就完成购买了。 回到搬瓦工的网站（如果没登陆的话，点击右上角的Client Area登陆），在导航栏点击Services，打开My Services。结果如图所示，就是你的VPS了。点击红框标出的KiwiVM Control Panel，可以进入你的VPS管理面板。可以看到VPS的当前运行状态，以及流量的使用量。 默认的OS(操作系统)应该是CentOS的，但因为本人常用Ubuntu，所以重新安装了Ubuntu系统。因为后面的步骤与系统有一定关联，所以你也可以重新安装一个新系统。点击左侧菜单栏中Install new OS,然后选择Ubuntu-14.04-x86，勾选下面的I agree...，点击Reload,等待数分钟就可以了。安装完成后，应该会有邮件通知，同时会告诉你新的密码。 这样，主机基本准备好了，接下来就是对VPS进行配置了，主要需要Linux命令行的一些知识。 这里有几点需要注意的信息，下面会有用到： VPS的IP，在之前的第7步中可以看到。 VPS的SSH Port,即SSH端口号,同上，可以在管理面板的Main controls中看到。 VPS的Root密码，邮箱里会有邮件，或者自己在管理面板的菜单栏选择Root password modification进行修改。 配置要配置VPS，就必须远程登陆这台主机。 你有两种方式可供选择： 使用SSH登陆工具，然后根据之前的IP、端口号、密码信息进行远程登陆。 管理面板中，点击左侧菜单栏中的Root shell-interactive，启动一个HTML5的shell界面。速度还是有点慢，一卡一卡的。 未完待续主机配置见下一篇《VPS主机搭建VPN》。 引用[1] 百度百科：VPN [2] 百度百科：VPS]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具 科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习资源汇总]]></title>
    <url>%2F2015%2F05%2F17%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[机器学习指南 机器学习入门资源不完全汇总 机器学习的最佳入门资源 持续更新ing…]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习 machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GPU计算]]></title>
    <url>%2F2015%2F05%2F17%2FGPU%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[GPU计算GPU计算，或称显卡计算，是指用计算机的图形处理器（Graphic Processing Unit，简称GPU）处理计算工作的计算方式。与之对应的是使用计算机处理器的（即Central Processing Unit，简称CPU）CPU计算。 与CPU计算相比GPU在科学计算方面拥有如下的优势： GPU由大量的运算单元（核心）组成，并行计算能力远高于CPU。 通常GPU拥有较普通内存位宽更大、频率更高的专用内存，即显存，适合处理大规模数据。 综上，CPU适合进行大量同类型数据的密集运算，如密码破译。 对于适合GPU处理的任务，CPU计算会比CPU计算快2-10倍之多。同时，在分布式计算项目中，GPU计算的得分效率也往往比CPU任务高出很多。 系统需求硬件需求显卡需要CUDA或OpenCL支持，可以使用GPU-Z查看显卡是否具备此功能。 软件需求新版本的Windows XP ATI/AMD显卡驱动不再兼容OpenCL计算，请考虑升级到Windows7或者使用旧版本（可能效率略低）。 安装相应支持GPU计算的驱动程序 使用项目方提供的GPU计算专用的客户端/优化计算程序 计算机程序有权限访问GPU资源 注意事项权限问题Windows 下，由于权限控制机制，以独立用户身份运行的 BOINC 无法正常检测 GPU。安装 BOINC 客户端时，请不要选择 “Protected access execution mode”（默认即不选）。 Linux 下，需要将运行客户端的用户加入适当的用户组（通常是 video），以保证客户端拥有足够的权限使用 GPU 资源。 资源占用GPU 计算可能导致计算机图形界面响应非常缓慢。越是低端的显卡，这种效应越发明显。 对于多显卡用户，可以禁用负责显示的显卡（通常是集成显卡或核心显卡），以避免影响系统正常使用。 性能考量GPU计算一般需要一些CPU资源进行命令。为了最大化GPU的利用程度，你可以手动提高GPU计算进程优先级以使其获得充足的CPU资源，也可以干脆留出一个CPU线程。 参考GPU计算]]></content>
      <tags>
        <tag>并行计算 GPU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建筑史观-建筑ABC]]></title>
    <url>%2F2015%2F05%2F16%2F%E5%BB%BA%E7%AD%91%E5%8F%B2%E8%A7%82-%E5%BB%BA%E7%AD%91ABC%2F</url>
    <content type="text"><![CDATA[史地维度与建筑质感史地维度建筑是历史范畴的 历史维度：与历史有关 在地维度：与地域相关 建筑质感不是随意追求质感 能不能有史地维度的质感？ 三元词与建筑演化三元词 建筑师 （architect） 建筑 （architecture） 建筑术 （architectonics） 结构 structure 构造 tectonic （建筑师要做的） 建造 construction vitruvious《建筑十书》 建筑演化古典主义 18世纪(启蒙运动，工业革命)开始，建筑与土木分家，建筑分到艺术学院 黑格尔美学，将建筑放在艺术之首 新古典主义 德国桑佩尔-《建筑四要素》 现代主义 20世纪柯布西耶-《走向新建筑》 后现代主义 大家觉得失去了精神寄托，觉得建筑缺少了史地维度，觉得时代性压倒了地域性。建筑像产品一样成批量生产，大家不满意了。 20世纪六七十年代 文丘里-《建筑的复杂性与矛盾性》 三原则与建筑理性建筑三原则： 坚固 durability 持久性 适用 convenience 便利 美观 beauty pleasure 美观性 建筑理性建筑是浪费空间的艺术？ 资源的有效性和建筑的适用性将使建筑的理性永远占据主流的位置。感性的东西是美的点缀。 理性主义 工具性 价值性 课后问答骨架与屋顶(frame and roof) 沙逊大厦（Sassoon House）和平饭店–钢筋混凝土结构 它的金字塔顶–钢结构 建筑是什么 支撑结构 围护体]]></content>
      <categories>
        <category>建筑学</category>
      </categories>
      <tags>
        <tag>建筑学 艺术 建筑史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo部署时git没有任何文件上传]]></title>
    <url>%2F2015%2F05%2F16%2Fhexo%E9%83%A8%E7%BD%B2%E6%97%B6git%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[跟着网上教程搭建hexo的时候碰到一个问题当我使用 $ hexo d 部署hexo的时候，我的gitpage怎么都没反应 然后我捣鼓了半天，都没搞明白怎么回事 后来发现我这里生成的没有.deploy目录，只有一个.deploy_git目录。然后手动改名 $ mv .deploy_git .deploy 重新部署，发现就好。真是无语了，暂时不知道什么缘故。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
