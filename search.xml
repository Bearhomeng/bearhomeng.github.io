<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>麻省理工（MIT）牛人解说数学体系</title>
      <link href="/2018/08/08/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%EF%BC%88MIT%EF%BC%89%E7%89%9B%E4%BA%BA%E8%A7%A3%E8%AF%B4%E6%95%B0%E5%AD%A6%E4%BD%93%E7%B3%BB/"/>
      <url>/2018/08/08/%E9%BA%BB%E7%9C%81%E7%90%86%E5%B7%A5%EF%BC%88MIT%EF%BC%89%E7%89%9B%E4%BA%BA%E8%A7%A3%E8%AF%B4%E6%95%B0%E5%AD%A6%E4%BD%93%E7%B3%BB/</url>
      <content type="html"><![CDATA[<h1 id="麻省理工（MIT）牛人解说数学体系"><a href="#麻省理工（MIT）牛人解说数学体系" class="headerlink" title="麻省理工（MIT）牛人解说数学体系"></a>麻省理工（MIT）牛人解说数学体系</h1><blockquote><p>原文出处： <a href="https://dahuasky.wordpress.com/2009/01/22/%E5%9C%A8%E6%95%B0%E5%AD%A6%E7%9A%84%E6%B5%B7%E6%B4%8B%E4%B8%AD%E9%A3%98%E8%8D%A1/" target="_blank" rel="noopener">林达华</a>   </p></blockquote><h2 id="为什么要深入数学的世界"><a href="#为什么要深入数学的世界" class="headerlink" title="为什么要深入数学的世界"></a>为什么要深入数学的世界</h2><p>作为计算机的学生，我没有任何企图要成为一个数学家。我学习数学的目的，是要想爬上巨人的肩膀，希望站在更高的高度，能把我自己研究的东西看得更深广一些。说起来，我在刚来这个学校的时候，并没有预料到我将会有一个深入数学的旅程。我的导师最初希望我去做的题目，是对appearance和motion建立一个unified的model。这个题目在当今Computer Vision中百花齐放的世界中并没有任何特别的地方。事实上，使用各种Graphical Model把各种东西联合在一起framework，在近年的论文中并不少见。</p><p>我不否认现在广泛流行的Graphical Model是对复杂现象建模的有力工具，但是，我认为它不是panacea，并不能取代对于所研究的问题的深入的钻研。如果统计学习包治百病，那么很多 “下游”的学科也就没有存在的必要了。事实上，开始的时候，我也是和Vision中很多人一样，想着去做一个Graphical Model——我的导师指出，这样的做法只是重复一些标准的流程，并没有很大的价值。经过很长时间的反复，另外一个路径慢慢被确立下来——我们相信，一个 图像是通过大量“原子”的某种空间分布构成的，原子群的运动形成了动态的可视过程。微观意义下的单个原子运动，和宏观意义下的整体分布的变换存在着深刻的 联系——这需要我们去发掘。</p><p>在深入探索这个题目的过程中，遇到了很多很多的问题，如何描述一个一般的运动过程，如何建立一个稳定并且广泛适用的原子表达，如何刻画微观运动和宏观分布变换的联系，还有很多。在这个过程中，我发现了两个事情：</p><ul><li>我原有的数学基础已经远远不能适应我对这些问题的深入研究。</li><li>在数学中，有很多思想和工具，是非常适合解决这些问题的，只是没有被很多的应用科学的研究者重视。</li></ul><p>于是，我决心开始深入数学这个浩瀚大海，希望在我再次走出来的时候，我已经有了更强大的武器去面对这些问题的挑战。</p><p>我的游历并没有结束，我的视野相比于这个博大精深的世界的依旧显得非常狭窄。在这里，我只是说说，在我的眼中，数学如何一步步从初级向高级发展，更高级别的数学对于具体应用究竟有何好处。</p><h2 id="集合论：现代数学的共同基础"><a href="#集合论：现代数学的共同基础" class="headerlink" title="集合论：现代数学的共同基础"></a>集合论：现代数学的共同基础</h2><p>现代数学有数不清的分支，但是，它们都有一个共同的基础——集合论——因为 它，数学这个庞大的家族有个共同的语言。集合论中有一些最基本的概念：集合(set)，关系(relation)，函数(function)，等价 (equivalence)，是在其它数学分支的语言中几乎必然存在的。对于这些简单概念的理解，是进一步学些别的数学的基础。我相信，理工科大学生对于 这些都不会陌生。</p><p>不过，有一个很重要的东西就不见得那么家喻户晓了——那就是“选择公理” (Axiom of Choice)。这个公理的意思是“任意的一群非空集合，一定可以从每个集合中各拿出一个元素。”——似乎是显然得不能再显然的命题。不过，这个貌似平常 的公理却能演绎出一些比较奇怪的结论，比如巴拿赫-塔斯基分球定理——“一个球，能分成五个部分，对它们进行一系列刚性变换（平移旋转）后，能组合成两个<strong>一样大小</strong>的球”。正因为这些完全有悖常识的结论，导致数学界曾经在相当长时间里对于是否接受它有着激烈争论。现在，主流数学家对于它应该是基本接受的，因为很多数学分支的重要定理都依赖于它。在我们后面要回说到的学科里面，下面的定理依赖于选择公理：</p><ol><li>拓扑学：Baire Category Theorem</li><li>实分析（测度理论）：Lebesgue 不可测集的存在性</li><li>泛函分析四个主要定理：Hahn-Banach Extension Theorem, Banach-Steinhaus Theorem (Uniform boundedness principle), Open Mapping Theorem, Closed Graph Theorem</li></ol><p><strong>在集合论的基础上，现代数学有两大家族：分析(Analysis)和代数(Algebra)。</strong>至于其它的，比如几何和概率论，在古典数学时代，它们是和代数并列的，但是它们的现代版本则基本是建立在分析或者代数的基础上，因此从现代意义说，它们和分析与代数并不是平行的关系。</p><h2 id="分析：在极限基础上建立的宏伟大厦"><a href="#分析：在极限基础上建立的宏伟大厦" class="headerlink" title="分析：在极限基础上建立的宏伟大厦"></a>分析：在极限基础上建立的宏伟大厦</h2><h3 id="微积分：分析的古典时代——从牛顿到柯西"><a href="#微积分：分析的古典时代——从牛顿到柯西" class="headerlink" title="微积分：分析的古典时代——从牛顿到柯西"></a>微积分：分析的古典时代——从牛顿到柯西</h3><p>先说说分析(Analysis)吧，它是从微积分(Caculus)发展起来 的——这也是有些微积分教材名字叫“数学分析”的原因。不过，分析的范畴远不只是这些，我们在大学一年级学习的微积分只能算是对古典分析的入门。分析研究 的对象很多，包括导数(derivatives)，积分(integral)，微分方程(differential equation)，还有级数(infinite series)——这些基本的概念，在初等的微积分里面都有介绍。如果说有一个思想贯穿其中，那就是极限——这是整个分析（不仅仅是微积分）的灵魂。</p><p>一个很多人都听说过的故事，就是牛顿(Newton)和莱布尼茨 (Leibniz)关于微积分发明权的争论。事实上，在他们的时代，很多微积分的工具开始运用在科学和工程之中，但是，微积分的基础并没有真正建立。那个 长时间一直解释不清楚的“无穷小量”的幽灵，困扰了数学界一百多年的时间——这就是“第二次数学危机”。直到柯西用数列极限的观点重新建立了微积分的基本 概念，这门学科才开始有了一个比较坚实的基础。直到今天，整个分析的大厦还是建立在极限的基石之上。</p><p>柯西(Cauchy)为分析的发展提供了一种严密的语言，但是他并没有解决微 积分的全部问题。在19世纪的时候，分析的世界仍然有着一些挥之不去的乌云。而其中最重要的一个没有解决的是“函数是否可积的问题”。我们在现在的微积分 课本中学到的那种通过“无限分割区间，取矩阵面积和的极限”的积分，是大约在1850年由黎曼(Riemann)提出的，叫做黎曼积分。但是，什么函数存 在黎曼积分呢（黎曼可积）？数学家们很早就证明了，定义在闭区间内的连续函数是黎曼可积的。可是，这样的结果并不令人满意，工程师们需要对分段连续函数的 函数积分。</p><h3 id="实分析：在实数理论和测度理论上建立起现代分析"><a href="#实分析：在实数理论和测度理论上建立起现代分析" class="headerlink" title="实分析：在实数理论和测度理论上建立起现代分析"></a>实分析：在实数理论和测度理论上建立起现代分析</h3><p>在19世纪中后期，不连续函数的可积性问题一直是分析的重要课题。对于定义在 闭区间上的黎曼积分的研究发现，可积性的关键在于“不连续的点足够少”。只有有限处不连续的函数是可积的，可是很多有数学家们构造出很多在无限处不连续的 可积函数。显然，在衡量点集大小的时候，有限和无限并不是一种合适的标准。在探讨“点集大小”这个问题的过程中，数学家发现实数轴——这个他们曾经以为已 经充分理解的东西——有着许多他们没有想到的特性。在极限思想的支持下，实数理论在这个时候被建立起来，它的标志是对实数完备性进行刻画的几条等价的定理 （确界定理，区间套定理，柯西收敛定理，Bolzano-Weierstrass Theorem和Heine-Borel Theorem等等）——这些定理明确表达出实数和有理数的根本区别：完备性（很不严格的说，就是对极限运算封闭）。随着对实数认识的深入，如何测量“点 集大小”的问题也取得了突破，勒贝格创造性地把关于集合的代数，和Outer content（就是“外测度”的一个雏形）的概念结合起来，建立了测度理论(Measure Theory)，并且进一步建立了以测度为基础的积分——勒贝格(Lebesgue Integral)。在这个新的积分概念的支持下，可积性问题变得一目了然。</p><p>上面说到的实数理论，测度理论和勒贝格积分，构成了我们现在称为实分析 (Real Analysis)的数学分支，有些书也叫实变函数论。对于应用科学来说，实分析似乎没有古典微积分那么“实用”——很难直接基于它得到什么算法。而且， 它要解决的某些“难题”——比如处处不连续的函数，或者处处连续而处处不可微的函数——在工程师的眼中，并不现实。但是，我认为，它并不是一种纯数学概念 游戏，它的现实意义在于为许多现代的应用数学分支提供坚实的基础。下面，我仅仅列举几条它的用处：</p><ol><li>黎曼可积的函数空间不是完备的，但是勒贝格可积的函数空间是完备的。简单的 说，一个黎曼可积的函数列收敛到的那个函数不一定是黎曼可积的，但是勒贝格可积的函数列必定收敛到一个勒贝格可积的函数。在泛函分析，还有逼近理论中，经 常需要讨论“函数的极限”，或者“函数的级数”，如果用黎曼积分的概念，这种讨论几乎不可想像。我们有时看一些paper中提到Lp函数空间，就是基于勒 贝格积分。</li><li>勒贝格积分是傅立叶变换（这东西在工程中到处都是）的基础。很多关于信号处理的初等教材，可能绕过了勒贝格积分，直接讲点面对实用的东西而不谈它的数学基础，但是，对于深层次的研究问题——特别是希望在理论中能做一些工作——这并不是总能绕过去。</li><li>在下面，我们还会看到，测度理论是现代概率论的基础。</li></ol><h3 id="拓扑学：分析从实数轴推广到一般空间——现代分析的抽象基础"><a href="#拓扑学：分析从实数轴推广到一般空间——现代分析的抽象基础" class="headerlink" title="拓扑学：分析从实数轴推广到一般空间——现代分析的抽象基础"></a>拓扑学：分析从实数轴推广到一般空间——现代分析的抽象基础</h3><p>随着实数理论的建立，大家开始把极限和连续推广到更一般的地方的分析。事实 上，很多基于实数的概念和定理并不是实数特有的。很多特性可以抽象出来，推广到更一般的空间里面。对于实数轴的推广，促成了点集拓扑学(Point- set Topology)的建立。很多原来只存在于实数中的概念，被提取出来，进行一般性的讨论。在拓扑学里面，有4个C构成了它的核心：</p><ol><li>Closed set（闭集合）。在现代的拓扑学的公理化体系中，开集和闭集是最基本的概念。一切从此引申。这两个概念是开区间和闭区间的推广，它们的根本地位，并不是 一开始就被认识到的。经过相当长的时间，人们才认识到：开集的概念是连续性的基础，而闭集对极限运算封闭——而极限正是分析的根基。</li><li>Continuous function （连续函数）。连续函数在微积分里面有个用epsilon-delta语言给出的定义，在拓扑学中它的定义是“开集的原像是开集的函数”。第二个定义和第 一个是等价的，只是用更抽象的语言进行了改写。我个人认为，它的第三个（等价）定义才从根本上揭示连续函数的本质——“连续函数是保持极限运算的函数” ——比如y是数列x1, x2, x3, … 的极限， 那么如果 f 是连续函数，那么 f(y) 就是 f(x1), f(x2), f(x3), …的极限。连续函数的重要性，可以从别的分支学科中进行类比。比如群论中，基础的运算是“乘法”，对于群，最重要的映射叫“同态映射”——保持“乘法”的 映射。在分析中，基础运算是“极限”，因此连续函数在分析中的地位，和同态映射在代数中的地位是相当的。</li><li>Connected set （连通集合）。比它略为窄一点的概念叫(Path connected)，就是集合中任意两点都存在连续路径相连——可能是一般人理解的概念。一般意义下的连通概念稍微抽象一些。在我看来，连通性有两个重 要的用场：一个是用于证明一般的中值定理(Intermediate Value Theorem)，还有就是代数拓扑，拓扑群论和李群论中讨论根本群(Fundamental Group)的阶。</li><li>Compact set（紧集）。Compactness似乎在初等微积分里面没有专门出现，不过有几条实数上的定理和它其实是有关系的。比如，“有界数列必然存在收敛子 列”——用compactness的语言来说就是——“实数空间中有界闭集是紧的”。它在拓扑学中的一般定义是一个听上去比较抽象的东西——“紧集的任意 开覆盖存在有限子覆盖”。这个定义在讨论拓扑学的定理时很方便，它在很多时候能帮助实现从无限到有限的转换。对于分析来说，用得更多的是它的另一种形式 ——“紧集中的数列必存在收敛子列”——它体现了分析中最重要的“极限”。Compactness在现代分析中运用极广，无法尽述。微积分中的两个重要定 理：极值定理(Extreme Value Theory)，和一致收敛定理(Uniform Convergence Theorem)就可以借助它推广到一般的形式。</li></ol><p>从某种意义上说，点集拓扑学可以看成是关于“极限”的一般理论，它抽象于实数理论，它的概念成为几乎所有现代分析学科的通用语言，也是整个现代分析的根基所在。</p><h3 id="微分几何：流形上的分析——在拓扑空间上引入微分结构"><a href="#微分几何：流形上的分析——在拓扑空间上引入微分结构" class="headerlink" title="微分几何：流形上的分析——在拓扑空间上引入微分结构"></a>微分几何：流形上的分析——在拓扑空间上引入微分结构</h3><p>拓扑学把极限的概念推广到一般的拓扑空间，但这不是故事的结束，而仅仅是开 始。在微积分里面，极限之后我们有微分，求导，积分。这些东西也可以推广到拓扑空间，在拓扑学的基础上建立起来——这就是微分几何。从教学上说，微分几何 的教材，有两种不同的类型，一种是建立在古典微机分的基础上的“古典微分几何”，主要是关于二维和三维空间中的一些几何量的计算，比如曲率。还有一种是建 立在现代拓扑学的基础上，这里姑且称为“现代微分几何”——它的核心概念就是“流形”(manifold)——就是在拓扑空间的基础上加了一套可以进行微 分运算的结构。现代微分几何是一门非常丰富的学科。比如一般流形上的微分的定义就比传统的微分丰富，我自己就见过三种从不同角度给出的等价定义——这一方 面让事情变得复杂一些，但是另外一个方面它给了同一个概念的不同理解，往往在解决问题时会引出不同的思路。除了推广微积分的概念以外，还引入了很多新概 念：tangent space, cotangent space, push forward, pull back, fibre bundle, flow, immersion, submersion 等等。</p><p>近些年，流形在machine learning似乎相当时髦。但是，坦率地说，要弄懂一些基本的流形算法， 甚至“创造”一些流形算法，并不需要多少微分几何的基础。对我的研究来说，微分几何最重要的应用就是建立在它之上的另外一个分支：李群和李代数——这是数 学中两大家族分析和代数的一个漂亮的联姻。分析和代数的另外一处重要的结合则是泛函分析，以及在其基础上的调和分析。</p><h2 id="代数：一个抽象的世界"><a href="#代数：一个抽象的世界" class="headerlink" title="代数：一个抽象的世界"></a>代数：一个抽象的世界</h2><h3 id="关于抽象代数"><a href="#关于抽象代数" class="headerlink" title="关于抽象代数"></a>关于抽象代数</h3><p>回过头来，再说说另一个大家族——代数。</p><p>如果说古典微积分是分析的入门，那么现代代数的入门点则是两个部分：线性代数(linear algebra)和基础的抽象代数(abstract algebra)——据说国内一些教材称之为近世代数。</p><p>代数——名称上研究的似乎是数，在我看来，主要研究的是运算规则。一门代数， 其实都是从某种具体的运算体系中抽象出一些基本规则，建立一个公理体系，然后在这基础上进行研究。一个集合再加上一套运算规则，就构成一个代数结构。在主 要的代数结构中，最简单的是群(Group)——它只有一种符合结合率的可逆运算，通常叫“乘法”。如果，这种运算也符合交换率，那么就叫阿贝尔群 (Abelian Group)。如果有两种运算，一种叫加法，满足交换率和结合率，一种叫乘法，满足结合率，它们之间满足分配率，这种丰富一点的结构叫做环(Ring)， 如果环上的乘法满足交换率，就叫可交换环(Commutative Ring)。如果，一个环的加法和乘法具有了所有的良好性质，那么就成为一个域(Field)。基于域，我们可以建立一种新的结构，能进行加法和数乘，就 构成了线性代数(Linear algebra)。</p><p>代数的好处在于，它只关心运算规则的演绎，而不管参与运算的对象。只要定义恰 当，完全可以让一只猫乘一只狗得到一头猪:-)。基于抽象运算规则得到的所有定理完全可以运用于上面说的猫狗乘法。当然，在实际运用中，我们还是希望用它 干点有意义的事情。学过抽象代数的都知道，基于几条最简单的规则，比如结合律，就能导出非常多的重要结论——这些结论可以应用到一切满足这些简单规则的地 方——这是代数的威力所在，我们不再需要为每一个具体领域重新建立这么多的定理。</p><p>抽象代数有在一些基础定理的基础上，进一步的研究往往分为两个流派：研究有限 的离散代数结构（比如有限群和有限域），这部分内容通常用于数论，编码，和整数方程这些地方；另外一个流派是研究连续的代数结构，通常和拓扑与分析联系在 一起（比如拓扑群，李群）。我在学习中的focus主要是后者。</p><h3 id="线性代数：“线性”的基础地位"><a href="#线性代数：“线性”的基础地位" class="headerlink" title="线性代数：“线性”的基础地位"></a>线性代数：“线性”的基础地位</h3><p>对于做Learning, vision, optimization或者statistics的人来说，接触最多的莫过于线性代数——这也是我们在大学低年级就开始学习的。线性代数，包括建立在它 基础上的各种学科，最核心的两个概念是向量空间和线性变换。线性变换在线性代数中的地位，和连续函数在分析中的地位，或者同态映射在群论中的地位是一样的 ——它是保持基础运算（加法和数乘）的映射。</p><p>在learning中有这样的一种倾向——鄙视线性算法，标榜非线性。也许在 很多场合下面，我们需要非线性来描述复杂的现实世界，但是无论什么时候，线性都是具有根本地位的。没有线性的基础，就不可能存在所谓的非线性推广。我们常 用的非线性化的方法包括流形和kernelization，这两者都需要在某个阶段回归线性。流形需要在每个局部建立和线性空间的映射，通过把许多局部线 性空间连接起来形成非线性；而kernerlization则是通过置换内积结构把原线性空间“非线性”地映射到另外一个线性空间，再进行线性空间中所能 进行的操作。而在分析领域，线性的运算更是无处不在，微分，积分，傅立叶变换，拉普拉斯变换，还有统计中的均值，通通都是线性的。</p><h3 id="泛函分析：从有限维向无限维迈进"><a href="#泛函分析：从有限维向无限维迈进" class="headerlink" title="泛函分析：从有限维向无限维迈进"></a>泛函分析：从有限维向无限维迈进</h3><p>在大学中学习的线性代数，它的简单主要因为它是在有限维空间进行的，因为有 限，我们无须借助于太多的分析手段。但是，有限维空间并不能有效地表达我们的世界——最重要的，函数构成了线性空间，可是它是无限维的。对函数进行的最重 要的运算都在无限维空间进行，比如傅立叶变换和小波分析。这表明了，为了研究函数（或者说连续信号），我们需要打破有限维空间的束缚，走入无限维的函数空 间——这里面的第一步，就是泛函分析。</p><p>泛函分析(Functional Analysis)是研究的是一般的线性空间，包括有限维和无限维，但是很多东西在有限维下显得很trivial，真正的困难往往在无限维的时候出现。在 泛函分析中，空间中的元素还是叫向量，但是线性变换通常会叫作“算子”(operator)。除了加法和数乘，这里进一步加入了一些运算，比如加入范数去 表达“向量的长度”或者“元素的距离”，这样的空间叫做“赋范线性空间”(normed space)，再进一步的，可以加入内积运算，这样的空间叫“内积空间”(Inner product space)。</p><p>大家发现，当进入无限维的时间时，很多老的观念不再适用了，一切都需要重新审视。</p><ol><li>所有的有限维空间都是完备的（柯西序列收敛），很多无限维空间却是不完备的（比如闭区间上的连续函数）。在这里，完备的空间有特殊的名称：完备的赋范空间叫巴拿赫空间(Banach space)，完备的内积空间叫希尔伯特空间(Hilbert space)。</li><li>在有限维空间中空间和它的对偶空间的是完全同构的，而在无限维空间中，它们存在微妙的差别。</li><li>在有限维空间中，所有线性变换（矩阵）都是有界变换，而在无限维，很多算子是无界的(unbounded)，最重要的一个例子是给函数求导。</li><li>在有限维空间中，一切有界闭集都是紧的，比如单位球。而在所有的无限维空间中，单位球都不是紧的——也就是说，可以在单位球内撒入无限个点，而不出现一个极限点。</li><li>在有限维空间中，线性变换（矩阵）的谱相当于全部的特征值，在无限维空间 中，算子的谱的结构比这个复杂得多，除了特征值组成的点谱(point spectrum)，还有approximate point spectrum和residual spectrum。虽然复杂，但是，也更为有趣。由此形成了一个相当丰富的分支——算子谱论(Spectrum theory)。</li><li>在有限维空间中，任何一点对任何一个子空间总存在投影，而在无限维空间中， 这就不一定了，具有这种良好特性的子空间有个专门的名称切比雪夫空间(Chebyshev space)。这个概念是现代逼近理论的基础(approximation theory)。函数空间的逼近理论在Learning中应该有着非常重要的作用，但是现在看到的运用现代逼近理论的文章并不多。</li></ol><h3 id="继续往前：巴拿赫代数，调和分析，和李代数"><a href="#继续往前：巴拿赫代数，调和分析，和李代数" class="headerlink" title="继续往前：巴拿赫代数，调和分析，和李代数"></a>继续往前：巴拿赫代数，调和分析，和李代数</h3><p>基本的泛函分析继续往前走，有两个重要的方向。第一个是巴拿赫代数 (Banach Algebra)，它就是在巴拿赫空间（完备的内积空间）的基础上引入乘法（这不同于数乘）。比如矩阵——它除了加法和数乘，还能做乘法——这就构成了一 个巴拿赫代数。除此以外，值域完备的有界算子，平方可积函数，都能构成巴拿赫代数。巴拿赫代数是泛函分析的抽象，很多对于有界算子导出的结论，还有算子谱 论中的许多定理，它们不仅仅对算子适用，它们其实可以从一般的巴拿赫代数中得到，并且应用在算子以外的地方。巴拿赫代数让你站在更高的高度看待泛函分析中 的结论，但是，我对它在实际问题中能比泛函分析能多带来什么东西还有待思考。</p><p>最能把泛函分析和实际问题在一起的另一个重要方向是调和分析 (Harmonic Analysis)。我在这里列举它的两个个子领域，傅立叶分析和小波分析，我想这已经能说明它的实际价值。它研究的最核心的问题就是怎么用基函数去逼近 和构造一个函数。它研究的是函数空间的问题，不可避免的必须以泛函分析为基础。除了傅立叶和小波，调和分析还研究一些很有用的函数空间，比如Hardy space，Sobolev space，这些空间有很多很好的性质，在工程中和物理学中都有很重要的应用。对于vision来说，调和分析在信号的表达，图像的构造，都是非常有用的 工具。</p><p>当分析和线性代数走在一起，产生了泛函分析和调和分析；当分析和群论走在一 起，我们就有了李群(Lie Group)和李代数(Lie Algebra)。它们给连续群上的元素赋予了代数结构。我一直认为这是一门非常漂亮的数学：在一个体系中，拓扑，微分和代数走到了一起。在一定条件下， 通过李群和李代数的联系，它让几何变换的结合变成了线性运算，让子群化为线性子空间，这样就为Learning中许多重要的模型和算法的引入到对几何运动 的建模创造了必要的条件。因此，我们相信李群和李代数对于vision有着重要意义，只不过学习它的道路可能会很艰辛，在它之前需要学习很多别的数学。</p><h2 id="现代概率论：在现代分析基础上再生"><a href="#现代概率论：在现代分析基础上再生" class="headerlink" title="现代概率论：在现代分析基础上再生"></a>现代概率论：在现代分析基础上再生</h2><p>最后，再简单说说很多Learning的研究者特别关心的数学分支：概率论。 自从Kolmogorov在上世纪30年代把测度引入概率论以来，测度理论就成为现代概率论的基础。在这里，概率定义为测度，随机变量定义为可测函数，条 件随机变量定义为可测函数在某个函数空间的投影，均值则是可测函数对于概率测度的积分。值得注意的是，很多的现代观点，开始以泛函分析的思路看待概率论的 基础概念，随机变量构成了一个向量空间，而带符号概率测度则构成了它的对偶空间，其中一方施加于对方就形成均值。角度虽然不一样，不过这两种方式殊途同 归，形成的基础是等价的。</p><p>在现代概率论的基础上，许多传统的分支得到了极大丰富，最有代表性的包括鞅论 (Martingale)——由研究赌博引发的理论，现在主要用于金融（这里可以看出赌博和金融的理论联系，:-P），布朗运动(Brownian Motion)——连续随机过程的基础，以及在此基础上建立的随机分析(Stochastic Calculus)，包括随机积分（对随机过程的路径进行积分，其中比较有代表性的叫伊藤积分(Ito Integral)），和随机微分方程。对于连续几何运用建立概率模型以及对分布的变换的研究离不开这些方面的知识。</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 一篇文章多个 categories</title>
      <link href="/2018/08/08/Hexo%20%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%A4%9A%E4%B8%AA%20categories/"/>
      <url>/2018/08/08/Hexo%20%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%A4%9A%E4%B8%AA%20categories/</url>
      <content type="html"><![CDATA[<h1 id="Hexo-一篇文章多个-categories"><a href="#Hexo-一篇文章多个-categories" class="headerlink" title="Hexo 一篇文章多个 categories"></a>Hexo 一篇文章多个 categories</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在很多情况下，我们希望在 Hexo 中写的一篇文章能够同时属于多个分类，例如我写了一篇<a href="http://aiellochan.com/2018/02/12/Webpack-%E7%9A%84-Chunk-id-%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84/" target="_blank" rel="noopener">模型检测工具汇总</a>，我既想将放在 <a href="http://aiellochan.com/categories/%F0%9F%96%A5-%E5%89%8D%E7%AB%AF%E7%9F%A5%E5%A4%9A%E5%B0%91/" target="_blank" rel="noopener">形式化验证</a> 这个分类下，又想将它放在 <a href="http://aiellochan.com/categories/%F0%9F%93%A6-Webpack-%E4%B8%93%E5%9C%BA/" target="_blank" rel="noopener">工具</a> 这个分类。</p><p>按照官方的解释，<code>categories</code> 这个选项有两种配置方法（其实有三种）。那我们就来讲讲这三种配置方法。</p><h3 id="子分类"><a href="#子分类" class="headerlink" title="子分类"></a>子分类</h3><p>下面的分类配置会将该文章放到 <code>Sports/Baseball</code> 这个分类下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Sports</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">Baseball</span></span><br></pre></td></tr></table></figure><p>同样的作用还可以这样写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span> <span class="string">[Sports,Baseball]</span></span><br></pre></td></tr></table></figure><p>上面两种写法最终的效果都是一样的，都是将文章放在了一个子分类目录下。</p><h3 id="多个分类"><a href="#多个分类" class="headerlink" title="多个分类"></a>多个分类</h3><p>如果我们的要求是将文章同时分到两个或者多个不同的类目下呢？官方给出的方法是：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">[Sports]</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">[Baseball]</span></span><br></pre></td></tr></table></figure><p>只需要用中括号将独立的分类括起来即可，这样上面的文章就会被分类在 <code>Sports</code> 和 <code>Baseball</code> 这两个不同的目录中了。</p><p>扩展一下，如果我们要将其分类到 <code>Sports/Baseball</code> 和 <code>Play</code> 两个不同的目录下（一个是子目录，一个是一级目录），我们该怎么写呢？如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">[Sports,Baseball]</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">[Play]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>代数结构简介：群、环, 域、格、模...</title>
      <link href="/2018/08/08/%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B%EF%BC%9A%E7%BE%A4%E3%80%81%E7%8E%AF,%20%E5%9F%9F%E3%80%81%E6%A0%BC%E3%80%81%E6%A8%A1/"/>
      <url>/2018/08/08/%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B%EF%BC%9A%E7%BE%A4%E3%80%81%E7%8E%AF,%20%E5%9F%9F%E3%80%81%E6%A0%BC%E3%80%81%E6%A8%A1/</url>
      <content type="html"><![CDATA[<h1 id="代数结构简介：群、环-域、格、模…"><a href="#代数结构简介：群、环-域、格、模…" class="headerlink" title="代数结构简介：群、环, 域、格、模…"></a>代数结构简介：群、环, 域、格、模…</h1><blockquote><p>群、环, 域、格、模、线性空间、域代数 </p></blockquote><p>现在数学是建立在集合论这个共同的基础上的，集合论中有一些基本的概念，如集合，关系，函数，等价等，作为数学各个分支的共同语言，本文中数学概念的定义也都是从集合出发的。 </p><h2 id="数学结构"><a href="#数学结构" class="headerlink" title="数学结构"></a><a href="https://en.wikipedia.org/wiki/Mathematical_structure" target="_blank" rel="noopener">数学结构</a></h2><p>数学中，集合上的结构是指集合上附加的、赋予集合特殊含义的数学对象。常见的结构有序(Order)、代数结构、拓扑(Topology)、测度(Measure)、度量(Metric)/几何、等价关系、范畴(Category)、微分结构等。上世纪中期盛极一时的法国布尔巴基学派(结构主义)曾提出数学的三种基本结构：</p><ul><li>代数结构：由集合及其上的运算组成，如群、环、域、模、线性空间等。</li><li>序结构：由集合及其上的序关系组成，如偏序集、全序集、良序集。</li><li>拓扑结构：由集合及其上的拓扑组成，如拓扑空间、度量空间、流形、紧致集等。</li></ul><p>之后，随着代数拓扑学、微分拓扑学、代数几何学、李群和代数群理论、多复变量函数论、泛函分析等领域趋于平稳，而难以结构化的数学分支，如分析数学、概率论与统计学、离散数学(组合数学)、应用数学、计算数学等开始蓬勃发展，布尔巴基学派逐渐衰微。(p.s.感觉后面这些数学都大都更适于计算机处理，计算机的普及促进了新数学领域的发展。)</p><h2 id="代数结构"><a href="#代数结构" class="headerlink" title="代数结构"></a><a href="https://en.wikipedia.org/wiki/Algebraic_structure" target="_blank" rel="noopener">代数结构</a></h2><p>抽象代数中，集合上的一个代数结构是指定义在集合上的一系列有限运算，而集合及其上的代数结构一起也被称为代数。常见的代数结构有群、环, 域、格、模、线性空间、域代数等。 </p><ul><li><code>群G(Group)</code>：群是集合上定义了一个满足闭合性、结合律、单位元、可逆性(任何元素有逆元素)四条公理的二元运算的代数结构。 注意上述公理中不包含交换律，交换律成立的群被称为阿贝尔群(交换群)。通常，群定义中的二元运算称为乘法，单位元写作1，此时群也被称为乘法群。对于满足交换律的阿贝尔群，二元运算通常称为加法，单位元写为0，因此阿贝尔群也被称为加法群。 可逆性意味着可以定义逆运算——除法，由于乘法不一定满足交换律，因此又可分为左除a^{-1}b(a\backslash b)a−1b(a\b)、右除ba^{-1}(b/a)ba−1(b/a)。对于满足交换律的阿贝尔群，两种除法相同，此时二元运算通常称为加法，逆运算称为减法。 <ul><li>半群：闭合于可结合二元运算下的集合形成的代数结构；相比群只要求二元运算满足闭合性和结合律，不需要有单位元和逆元。</li><li><strong>幺半群(Monoid)</strong>：定义了可结合二元运算和单位元的代数结构，是带有单位元的半群；相比群不要求有逆元。</li><li>类似的代数结构还有：原群(Magma) &gt; 拟群(Quasigroup, Loop) &gt; 半群；半群胚 &gt; <strong>范畴(Category)</strong> &gt; 群胚(Groupoid)</li><li>范畴不要求闭合性，但要求结合律和单位元，幺半群是特殊的范畴，只有一个对象(Object)。</li></ul></li><li><p><code>环R(Ring)</code>：环是集合上定义了满足特定公理的广义加法和乘法两个二元运算的代数结构。</p><ul><li>环是一个关于加法的阿贝尔群：定义有满足结合律、交换律、单位元、可逆性的加法运算。</li><li>环是一个关于乘法的半群：定义有满足结合律的乘法运算。</li><li>环的乘法关于加法满足分配律。</li><li>无零因子环：没有非0零因子的环称为无零因子环，0是唯一的零因子；等价的，也可以说是满足零乘性质的环：任何非0元素的乘积非0或If ab=0ab=0, then a=0a=0 or b=0b=0；还可以说R{0}对乘法封闭，构成一个半群。</li><li>幺环：如果环的乘法有单位元，则环是关于乘法的幺半群，环被称为幺环(维基中环的定义要求乘法有单位元)。</li><li>交换环(Commutative Ring)：环的加法满足交换律，但乘法不要求满足交换律；乘法满足交换律的环称为交换环。</li><li>除环/反称域(Division Ring/Skew Field)：环不要求乘法满足可逆性，乘法满足可逆性的幺环称为除环，等价的可以说R{0}对乘法形成一个群。除环不要求乘法的交换性，非交换的除环是体，交换的除环是域。</li><li>整环/整域(Entire Ring/Integral Domain)：无零因子的交换幺环；整环是整数环的推广，非零元素满足消去律：If a≠0a≠0, ab=acab=ac implies b=cb=c。</li><li><strong>域F(Field)</strong>：乘法满足交换律、可逆性，且有单位元的环称为域；域是交换的除环，是任何非零元素都有逆元素的整环。<br>抽象代数中，中文的<code>域</code>一般指Field，英文维基的环论下还有一个域(Domain)，没有对应的中文词条。域(Domain)是一个满足零乘性质的非零环，即非零的无零因子环。</li><li><strong>向量空间V(Vector Space)</strong>：向量空间也称线性空间(Linear Space)，是域F上的一个集合，其中定义了向量加法和标量乘法两种运算，向量加法满足结合律、交换律、单位元、可逆性，而标量乘法与标量的域乘法相容a(bα) = (ab)αa(bα)=(ab)α、有单位元、对向量加法及标量的域加法满足分配律。</li><li><strong>模M(Module)</strong>：Module over a Ring \rightarrow→ Vector Space over a Field；模是对线性空间概念的推广，线性空间中标量的代数结构是域(Field)，而模则将标量放宽到任意环(Ring)的元素，乘法运算定义在环元素与模元素之间。由于乘法不一定满足交换律，又可分为左R-模、右R-模。</li><li><strong>域代数(Algebra over a Field)</strong>：线性空间再加上一个双线性运算(乘法)即成为域代数，如矩阵代数、张量代数、李代数、外代数。类似于线性空间推广到模，将标量的域F替换为交换环R，可以推广得到环代数(Algebra over a Ring)。</li></ul></li><li><p><code>格L(Lattice)</code>：从序理论角度定义，格是一个偏序集，其非空有限子集都有一个上确界(并)和一个下确界(交)；从抽象代数角度定义，格是定义了满足交换律、结合律及吸收律三个公理的两个二元运算(交并)的集合。</p></li></ul><p>代数结构由集合上的满足特定公理的运算定义，而将这些代数结构本身作为研究对象的学科便是<code>泛代数</code>。<strong>范畴论</strong>是另一种研究代数结构间关系的工具：范畴是一系列对象及对象间箭头(态射)构成的代数结构；任意代数结构都有其同态的概念，从而可以构成一个范畴，比如所有的群及群同态便构成了群范畴。范畴论在编程语言理论中有重要应用，如函数式编程中单子的概念。 </p><h2 id="空间"><a href="#空间" class="headerlink" title="空间"></a><a href="https://en.wikipedia.org/wiki/Space_%28mathematics%29" target="_blank" rel="noopener">空间</a></h2><p>容纳运动是空间的本质特征，这里所说的运动是从一个点到另一个点的变换，而不是微积分意义上的“连续”性的运动。<br>认识到了这些，我们就可以把我们关于三维空间的认识扩展到其他的空间。事实上，不管是什么空间，都必须容纳和支持在其中发生的符合规则的运动（变换）。你会发现，在某种空间中往往会存在一种相对应的变换，比如拓扑空间中有拓扑变换，线性空间中有线性变换，仿射空间中有仿射变换，其实这些变换都只不过是对应空间中允许的运动形式而已。因此只要知道，“空间”是容纳运动的一个对象集合，而变换则规定了对应空间的运动。</p><h3 id="代数空间"><a href="#代数空间" class="headerlink" title="代数空间"></a>代数空间</h3><p>数学中，空间是指有额外(数学)结构的集合。常见的有线性空间(向量空间)、仿射空间、拓扑空间、测度空间、度量空间、赋范空间、内积空间、函数空间等。</p><p>度量空间是能在上面定义收敛, 连续概念的空间, 比度量空间更一般的空间是拓扑空间, 在拓扑空间上也能定义收敛和连续概念。<br>而测度空间是能在上面定义(Lebsegue)积分的空间。<br>赋范空间是线性空间中添加了距离的概念(范数)，而内积空间是线性空间添加了距离和角度两个概念(内积)。</p><p>测度空间与可测空间的区别, 可测空间是能在上面定义测度, 测度空间是已经在上面定义了测度。</p><p><img src="http://jwzsstore.qiniudn.com/18-8-8/34871899.jpg" alt="[Overview of types of abstract spaces(wikipedia).](https://yelf.me/images/Notes/math-space.jpg)扩展阅读"></p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p><a href="http://blog.jobbole.com/94591/" target="_blank" rel="noopener">MIT牛人解说数学体系</a><br><a href="https://blog.csdn.net/myan/article/details/647511" target="_blank" rel="noopener">理解矩阵-孟岩</a></p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 形式化方法 </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模型检测工具汇总</title>
      <link href="/2018/08/08/%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/"/>
      <url>/2018/08/08/%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>参考 <a href="http://www.yingzinanfei.com/2017/02/01/moxingjiancegongjuhuizong/" target="_blank" rel="noopener">模型检测工具汇总</a></p><h2 id="面向形式化规格语言的模型检测工具"><a href="#面向形式化规格语言的模型检测工具" class="headerlink" title="面向形式化规格语言的模型检测工具"></a>面向形式化规格语言的模型检测工具</h2><h3 id="SMV-Symbolic-Model-Verifier"><a href="#SMV-Symbolic-Model-Verifier" class="headerlink" title="SMV(Symbolic Model Verifier)"></a>SMV(Symbolic Model Verifier)</h3><ul><li>符号模型检测工具</li></ul><ul><li>SMV用以检测一个有限状态系统是否满足CTL公式。</li><li>它的建模方式是以模块为单位，模块可以同步或异步组合，模块描述的基本要素包括非确定性选择，状态转换和并行赋值语句。</li><li>其模型检测的基本方法是以二叉图表示状态转换关系，以计算不动点的方法检测状态的可达性和其所满足的性质。</li><li><a href="http://www.cs.cmu.edu/~modelcheck/smv.html" target="_blank" rel="noopener">http://www.cs.cmu.edu/~modelcheck/smv.html</a></li></ul><h3 id="NuSmv-New-Symbolic-Model-Verifier"><a href="#NuSmv-New-Symbolic-Model-Verifier" class="headerlink" title="NuSmv(New Symbolic Model Verifier)"></a>NuSmv(New Symbolic Model Verifier)</h3><ul><li>新符号模型检测工具</li></ul><ul><li>对SMV重构的一个模型检测工具</li><li>支持计算树逻辑CTL和线性时序逻辑LTL描述的所有规范</li><li>整合了以 SAT 为基础的有界模型检测技术</li><li><a href="http://nusmv.fbk.eu/" target="_blank" rel="noopener">http://nusmv.fbk.eu/</a></li></ul><h3 id="nuXmv"><a href="#nuXmv" class="headerlink" title="nuXmv"></a>nuXmv</h3><ul><li><p>分析同步有限状态和无限状态系统的新符号模型检测工具</p></li><li><p>扩展于NuSMV</p></li><li><p>对于有限状态的情形，nuXmv特点是基于SAT算法的有效验证引擎</p></li><li>对于无限状态的情形，nuXmv特点是基于SMT的验证技术，与MathSAT5紧密集成</li><li><a href="https://nuxmv.fbk.eu/" target="_blank" rel="noopener">https://nuxmv.fbk.eu/</a></li><li>Uppaal(Uppsala University &amp; Aalborg University) 时间自动机的模型检测工具</li><li>建模和模拟及验证实时系统的工具</li><li><a href="http://www.uppaal.org/" target="_blank" rel="noopener">http://www.uppaal.org/</a></li></ul><h3 id="STeP-Stanford-Temporal-Prover"><a href="#STeP-Stanford-Temporal-Prover" class="headerlink" title="STeP(Stanford Temporal Prover)"></a>STeP(Stanford Temporal Prover)</h3><ul><li><p>斯坦福时间验证器</p></li><li><p>用模型检测器处理子系统的验证问题</p></li><li><p>用定理证明器将结果汇总处理</p></li><li>不限于有限状态系统</li><li>用推论方式联合模型检测应用于更广泛的系统，包括无限数据域的程序</li><li><a href="http://www-step.stanford.edu/" target="_blank" rel="noopener">http://www-step.stanford.edu/</a></li></ul><h3 id="CWB-Concurrency-Workbench"><a href="#CWB-Concurrency-Workbench" class="headerlink" title="CWB(Concurrency Workbench)"></a>CWB(Concurrency Workbench)</h3><ul><li><p>适用于并发系统操作与分析的自动化工具</p></li><li><p>可以检测系统模型之间的等价关系、FRE-ORDER关系和系统是否能够满足$\mu$-演算的公式</p></li><li><p>建模方法使用CCS语言或LOTOS语言的子集</p></li><li>能分析给定程序的状态空间及检测多种语义的等价性和序列性</li><li><a href="http://homepages.inf.ed.ac.uk/perdita/cwb/" target="_blank" rel="noopener">http://homepages.inf.ed.ac.uk/perdita/cwb/</a></li></ul><h3 id="VIS-Verification-Interacting-with-Synthesis"><a href="#VIS-Verification-Interacting-with-Synthesis" class="headerlink" title="VIS(Verification Interacting with Synthesis)"></a>VIS(Verification Interacting with Synthesis)</h3><ul><li><p>用于形式验证、综合和模拟有限状态系统的工具</p></li><li><p>能够综合有限状态系统并验证这些系统的属性</p></li><li><p><a href="http://vlsi.colorado.edu/~vis/" target="_blank" rel="noopener">http://vlsi.colorado.edu/~vis/</a></p></li></ul><h2 id="面向源程序语言的模型检测工具"><a href="#面向源程序语言的模型检测工具" class="headerlink" title="面向源程序语言的模型检测工具"></a>面向源程序语言的模型检测工具</h2><h3 id="SPIN-Simple-Promela-Interpreter"><a href="#SPIN-Simple-Promela-Interpreter" class="headerlink" title="SPIN(Simple Promela Interpreter)"></a>SPIN(Simple Promela Interpreter)</h3><ul><li><p>显式模型检测工具</p></li><li><p>SPIN 用以检测一个有限状态系统是否满足PLTL公式及其他一些性质，包括可达性和循环。</p></li><li><p>建模方式是以进程为单位，进程异步组合，进程描述的基本要素包括赋值语句，条件语句，通讯语句，非确定性选择和循环语句。</p></li><li>基本方法是以自动机表示各进程和PLTL公式，以计算这些自动机的组合可接受的语言是否为空的方法检测进程模型是否满足给定的性质。</li><li>建模语言为PROMELA(PROcess MEta LAnguage)，基于进程结构，有类似C语言的结构</li><li><a href="http://spinroot.com/spin/whatispin.html" target="_blank" rel="noopener">http://spinroot.com/spin/whatispin.html</a></li></ul><h3 id="BLAST-Berkeley-Lazy-Abstraction-Software-Verification-Tool"><a href="#BLAST-Berkeley-Lazy-Abstraction-Software-Verification-Tool" class="headerlink" title="BLAST(Berkeley Lazy Abstraction Software Verification Tool)"></a>BLAST(Berkeley Lazy Abstraction Software Verification Tool)</h3><ul><li><p>C 程序的时序安全属性自动验证工具</p></li><li><p>基于反例引导的抽象求精框架对C语言程序进行检测</p></li><li><p>采用懒惰抽象(lazy abstraction)技术，有效地提高了效率</p></li><li><a href="http://cseweb.ucsd.edu/~rjhala/blast.html" target="_blank" rel="noopener">http://cseweb.ucsd.edu/~rjhala/blast.html</a></li></ul><h3 id="SLAM-C程序模型检测工具"><a href="#SLAM-C程序模型检测工具" class="headerlink" title="SLAM C程序模型检测工具"></a>SLAM C程序模型检测工具</h3><ul><li><p>将原C语言程序抽象为布尔程序进程验证工作</p></li><li><p>抽象后的程序仅剩下布尔变量</p></li><li>依靠C2bp,Bebop,Newton3个工具分别负责完成抽象、检测和抽象求精任务</li><li><a href="https://www.microsoft.com/en-us/research/project/slam/" target="_blank" rel="noopener">https://www.microsoft.com/en-us/research/project/slam/</a></li></ul><h3 id="JPF-Java-Path-Finder"><a href="#JPF-Java-Path-Finder" class="headerlink" title="JPF(Java Path Finder)"></a>JPF(Java Path Finder)</h3><ul><li><p>Java程序验证工具</p></li><li><p>实现了一个 MC-JVM 来解决内存分配和垃圾回收等问题</p></li><li><p><a href="http://babelfish.arc.nasa.gov/trac/jpf" target="_blank" rel="noopener">http://babelfish.arc.nasa.gov/trac/jpf</a></p></li></ul><h3 id="VeriSoft"><a href="#VeriSoft" class="headerlink" title="VeriSoft"></a>VeriSoft</h3><ul><li>直接测试 C 源代码</li></ul><h3 id="Eraser"><a href="#Eraser" class="headerlink" title="Eraser"></a>Eraser</h3><ul><li>能够检测 Java 代码</li></ul><h3 id="Jchecker"><a href="#Jchecker" class="headerlink" title="Jchecker"></a>Jchecker</h3><ul><li><p>C 程序模型检测工具</p></li><li><p>基于谓词抽象理论</p></li><li><p>采用基于谓词抽象的反例引导的抽象求精框架</p></li><li>能够针对C程序源码抽象出模型并完备地搜索其状态空间，以此验证程序的安全属性</li><li>最大限度缩减状态空间</li></ul><h3 id="Bandera"><a href="#Bandera" class="headerlink" title="Bandera"></a>Bandera</h3><ul><li><p>并发Java程序的模型检测工具</p></li><li><p>工具平台</p></li><li><p>基于程序切片技术，将Java程序转换成中间代码</p></li><li>后端接口适应多种模型检测器，包括SPIN和SMV</li><li><a href="http://bandera.projects.cs.ksu.edu/" target="_blank" rel="noopener">http://bandera.projects.cs.ksu.edu/</a></li></ul><h3 id="Klocwork-InsightPro"><a href="#Klocwork-InsightPro" class="headerlink" title="Klocwork InsightPro"></a>Klocwork InsightPro</h3><ul><li>可以检测多种语言类型的多种质量缺陷和安全漏洞</li></ul><h3 id="CMC"><a href="#CMC" class="headerlink" title="CMC"></a>CMC</h3><ul><li>可以检测C语言程序在执行时OS层级的调度</li></ul><h3 id="MaceMC"><a href="#MaceMC" class="headerlink" title="MaceMC"></a>MaceMC</h3><ul><li><p>用于检测分布式系统</p></li><li><p><a href="http://www.macesystems.org/wiki/macemc" target="_blank" rel="noopener">http://www.macesystems.org/wiki/macemc</a></p></li></ul><h3 id="Chess"><a href="#Chess" class="headerlink" title="Chess"></a>Chess</h3><ul><li><p>用于检测多线程的Windows程序</p></li><li><p><a href="https://www.microsoft.com/en-us/research/project/chess-find-and-reproduce-heisenbugs-in-concurrent-programs/" target="_blank" rel="noopener">https://www.microsoft.com/en-us/research/project/chess-find-and-reproduce-heisenbugs-in-concurrent-programs/</a></p></li></ul><h3 id="FDR"><a href="#FDR" class="headerlink" title="FDR"></a>FDR</h3><ul><li><a href="https://www.cs.ox.ac.uk/projects/fdr/" target="_blank" rel="noopener">https://www.cs.ox.ac.uk/projects/fdr/</a></li></ul><h3 id="Murphi"><a href="#Murphi" class="headerlink" title="Murphi"></a>Murphi</h3><ul><li><p>一种枚举显示状态的模型检测器，针对C语言</p></li><li><p><a href="http://formalverification.cs.utah.edu/Murphi/" target="_blank" rel="noopener">http://formalverification.cs.utah.edu/Murphi/</a></p></li></ul><h3 id="MoonWalker"><a href="#MoonWalker" class="headerlink" title="MoonWalker"></a>MoonWalker</h3><ul><li>针对.NET应用的模型检测工具</li></ul><h3 id="XMC"><a href="#XMC" class="headerlink" title="XMC"></a>XMC</h3><ul><li>对JAVA程序中同步操作算法检测</li></ul><h3 id="FLAVERS-FLow-Analysis-for-VERification-of-Systems"><a href="#FLAVERS-FLow-Analysis-for-VERification-of-Systems" class="headerlink" title="FLAVERS(FLow Analysis for VERification of Systems)"></a>FLAVERS(FLow Analysis for VERification of Systems)</h3><ul><li>针对ADA语言的工具</li><li><a href="http://formalverification.cs.utah.edu/Murphi/" target="_blank" rel="noopener">http://formalverification.cs.utah.edu/Murphi/</a></li></ul><h3 id="Mocha"><a href="#Mocha" class="headerlink" title="Mocha"></a>Mocha</h3><ul><li><p>针对C语言的模型检测工具</p></li><li><p><a href="https://www.cis.upenn.edu/~mocha/" target="_blank" rel="noopener">https://www.cis.upenn.edu/~mocha/</a></p></li></ul><h3 id="CBMC"><a href="#CBMC" class="headerlink" title="CBMC"></a>CBMC</h3><ul><li><p>针对C语言/C++的模型检测工具</p></li><li><p><a href="http://www.cprover.org/cbmc/" target="_blank" rel="noopener">http://www.cprover.org/cbmc/</a></p></li></ul><h3 id="MAGIC-Modular-Analysis-of-proGrams-In-C"><a href="#MAGIC-Modular-Analysis-of-proGrams-In-C" class="headerlink" title="MAGIC(Modular Analysis of proGrams In C)"></a>MAGIC(Modular Analysis of proGrams In C)</h3><ul><li><p>针对C语言的模型检测工具</p></li><li><p><a href="http://www.cs.cmu.edu/~chaki/magic/" target="_blank" rel="noopener">http://www.cs.cmu.edu/~chaki/magic/</a></p></li></ul><h2 id="其他模型检测工具"><a href="#其他模型检测工具" class="headerlink" title="其他模型检测工具"></a>其他模型检测工具</h2><ol><li><p>OFMC 一种用于安全协议的符号模型检测工具</p></li><li><p>CoPS 持久安全性检测器</p></li><li>Rational Tau</li><li>F-Soft</li><li>IMPACT</li><li>Astree analysis tool</li><li>Saturn</li><li>Calysto</li><li>Terminator</li><li>SATABS</li><li>Terminator</li><li>mCRL2(micro Common Representation Language) 并发系统检测工具</li><li>LTSA(Labeled Transition System Analyzer) 并发系统检测工具</li><li>Maude 基于逻辑语义的工具</li><li>ISP MPI程序的检测工具</li><li>CHIC(Checker for Interface Compatibility) 模块行为兼容性的验证工具</li><li>MRMC(Markov Reward Model) 对离散和连续时间的马尔可夫激励模型</li><li>UMLChecker UML模型检测工具</li><li>BACH(Bounded ReachAblity CHecker) 用于分析线性混成自动机有界可达性分析</li><li>LDPChecker 针对正环闭合自动机(Positive Loop-closed Automata)检验线性时段性质</li><li>QRDChecker 针对时段时序逻辑QRDC(Quantified Restrictred Duration Calculs)的检验工具</li><li>Kronos</li><li>HyTech</li><li>AUTOABS</li><li>FeaVer</li><li>3VMC</li><li>aSpin</li></ol><h2 id="其他分类方式"><a href="#其他分类方式" class="headerlink" title="其他分类方式"></a>其他分类方式</h2><ul><li>结合模型检测与定理证明<ul><li>STeP</li></ul></li><li>符号模型检测<ul><li>用有序二叉图OBDDs(Ordered Binary Decision Diagrams)描述状态迁移图</li><li>用布尔逻辑公式描述系统属性</li></ul></li><li>定界模型检测技术(bounded model checking)<ul><li>依赖于布尔可满足性问题(boolean satisfiability problem, SAT)的求解器</li><li>在限定步数k内，确定系统是否满足性质。</li><li>若不能确定，则增加k值，重新进行验证</li></ul></li><li>其他分类方式<ul><li>基于自动机理论<ul><li>SPIN</li></ul></li><li>基于不动点定理<ul><li>SMV</li></ul></li></ul></li></ul><h2 id="其他分类方式-1"><a href="#其他分类方式-1" class="headerlink" title="其他分类方式"></a>其他分类方式</h2><ul><li>针对实时系统的模型检测工具<ul><li>UPPAAL, Kronos, STeP</li></ul></li><li>针对并发系统的模型检测工具<ul><li>Spin, JPF, Verisoft</li></ul></li><li>针对混成系统的模型检测工具<ul><li>HyTech, HySAT, BACH, LDPChecker</li></ul></li><li>模型检测的步骤：</li><li>抽象出系统的数学模型<ul><li>迁移系统</li><li>马尔可夫链</li><li>Kripke结构</li></ul></li><li>给出能够描述该系统性质的语言</li><li>线性时序逻辑LTL<ul><li>关心系统的任意一次运行中的状态以及它们之间的关系</li></ul></li><li>分支时序逻辑CTL<ul><li>分叉时序逻辑，用来描述状态的前后关系和分支情况</li></ul></li><li>$\mu$-演算<ul><li>关心系统的动作与状态之间的关系</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 形式化验证 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 模型检测 </tag>
            
            <tag> 形式化验证 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo博客Next主题优化总结</title>
      <link href="/2018/07/26/Hexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/26/Hexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="Hexo博客Next主题优化总结"><a href="#Hexo博客Next主题优化总结" class="headerlink" title="Hexo博客Next主题优化总结"></a>Hexo博客Next主题优化总结</h1><blockquote><p>本博客使用的是Next主题，看到别人使用Next主题搭建的博客具有一些比较炫的效果，自己也尝试了一番，下边将自己配置过程进行了总结，防止日后再用的时候忘记。 </p></blockquote><h2 id="1-修改文章字体的大小"><a href="#1-修改文章字体的大小" class="headerlink" title="1. 修改文章字体的大小"></a>1. 修改文章字体的大小</h2><p>在PC端显示的字体大小还算可以，但是移动端显示的字体太小，因此需要对字体大小进行修改。<br>打开Next主题的配置文件<code>_config.yml</code>，将global属性的size设置为16。更为详细的设置可以</p><p>参考：<a href="http://theme-next.iissnan.com/theme-settings.html#fonts-customization" target="_blank" rel="noopener">Next主题官方文档：主题配置</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global font settings used on &lt;body&gt; element.</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line"><span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">family:</span> <span class="string">Lato</span></span><br><span class="line"><span class="attr">size:</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="2-博客首页文章摘要显示图片"><a href="#2-博客首页文章摘要显示图片" class="headerlink" title="2. 博客首页文章摘要显示图片"></a>2. 博客首页文章摘要显示图片</h2><p>给文章的<code>Front-matter</code>添加photos字段。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: Fiddler断点调试</span><br><span class="line">date: 2018-01-25 14:08:12</span><br><span class="line">tags: 测试</span><br><span class="line">categories: 移动开发</span><br><span class="line">updated:</span><br><span class="line">photos: &apos;http://oyctsei1h.bkt.clouddn.com/text.png&apos;</span><br><span class="line">copyright: true</span><br></pre></td></tr></table></figure><p>添加了<code>photos</code>字段后，在博客首页就会显示对应的图片。每个标签的含义可以参考：<a href="https://hexo.io/zh-cn/docs/front-matter.html" target="_blank" rel="noopener">Hexo官方文档</a></p><h2 id="3-增加站内搜索"><a href="#3-增加站内搜索" class="headerlink" title="3. 增加站内搜索"></a>3. 增加站内搜索</h2><blockquote><p>参考博客：<a href="https://www.ezlippi.com/blog/2017/02/hexo-search.html" target="_blank" rel="noopener">Hexo博客添加站内搜索</a></p></blockquote><p>Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候，从这个文件中根据关键字检索出相应的链接。</p><p>安装<code>hexo-generator-search</code>插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>安装<code>hexo-generator-searchdb</code>插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>启动搜索：编辑站点配置文件<code>/work/blog-hexo/_config.yml</code>，增加以下内容到任意位置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Add search function</span></span><br><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> <span class="string">search.xml</span></span><br><span class="line"><span class="attr">  field:</span> <span class="string">post</span></span><br><span class="line"><span class="attr">  format:</span> <span class="string">html</span></span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><h2 id="4-增加底部版权声明"><a href="#4-增加底部版权声明" class="headerlink" title="4. 增加底部版权声明"></a>4. 增加底部版权声明</h2><blockquote><p>参考博客:<a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p></blockquote><p>在主题目录<code>next/layout/_macro/</code>下添加文件<code>my-copyright.swig</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if page.copyright %&#125;</span><br><span class="line">&lt;div class=&quot;my_post_copyright&quot;&gt;</span><br><span class="line">  &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- JS库 sweetalert 可修改路径 --&gt;</span><br><span class="line">  &lt;script type=&quot;text/javascript&quot; src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/jquery-1.7.1.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script src=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://jslibs.wuxubj.cn/sweetalert_mini/sweetalert.mini.css&quot;&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &lt;span class=&quot;copy-path&quot;  title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot;  aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">  &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var clipboard = new Clipboard(&apos;.fa-clipboard&apos;);</span><br><span class="line">    clipboard.on(&apos;success&apos;, $(function()&#123;</span><br><span class="line">      $(&quot;.fa-clipboard&quot;).click(function()&#123;</span><br><span class="line">        swal(&#123;</span><br><span class="line">          title: &quot;&quot;,</span><br><span class="line">          text: &apos;复制成功&apos;,</span><br><span class="line">          html: false,</span><br><span class="line">          timer: 500,</span><br><span class="line">          showConfirmButton: false</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>在目录<code>next/source/css/_common/components/post/</code>下添加文件<code>my-post-copyright.styl</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">.my_post_copyright &#123;</span><br><span class="line">  width: 85%;</span><br><span class="line">  max-width: 45em;</span><br><span class="line">  margin: 2.8em auto 0;</span><br><span class="line">  padding: 0.5em 1.0em;</span><br><span class="line">  border: 1px solid #d3d3d3;</span><br><span class="line">  font-size: 0.93rem;</span><br><span class="line">  line-height: 1.6em;</span><br><span class="line">  word-break: break-all;</span><br><span class="line">  background: rgba(255,255,255,0.4);</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright p&#123;margin:0;&#125;</span><br><span class="line">.my_post_copyright span &#123;</span><br><span class="line">  display: inline-block;</span><br><span class="line">  width: 5.2em;</span><br><span class="line">  color: #b5b5b5;</span><br><span class="line">  font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .raw &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 5em;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  border-bottom:0;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright a:hover &#123;</span><br><span class="line">  color: #a3d2a3;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright:hover .fa-clipboard &#123;</span><br><span class="line">  color: #000;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .post-url:hover &#123;</span><br><span class="line">  font-weight: normal;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path &#123;</span><br><span class="line">  margin-left: 1em;</span><br><span class="line">  width: 1em;</span><br><span class="line">  +mobile()&#123;display:none;&#125;</span><br><span class="line">&#125;</span><br><span class="line">.my_post_copyright .copy-path:hover &#123;</span><br><span class="line">  color: #808080;</span><br><span class="line">  cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改<code>next/layout/_macro/post.swig</code>,在代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &apos;wechat-subscriber.swig&apos; %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>之前添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">      &#123;% include &apos;my-copyright.swig&apos; %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br></pre></td></tr></table></figure><p>截图如下： </p><p> <img src="http://oyctsei1h.bkt.clouddn.com/%E6%B7%BB%E5%8A%A0%E7%89%88%E6%9D%83.png" alt="img"> </p><p>修改<code>next/source/css/_common/components/post/post.styl</code>文件，在最后一行增加代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;my-post-copyright&quot;</span><br></pre></td></tr></table></figure><p>然后保存。</p><p>如果需要为文章添加版权信息，只需要在当前博客或者模板文件的<code>Front-matter</code>中添加字段：<code>copyright: true</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: ubuntu16.04安装Jdk1.6与多版本jdk切换</span><br><span class="line">tags: linux</span><br><span class="line">categories: Linux</span><br><span class="line">date: 2018-01-24 15:06:10</span><br><span class="line">updated:</span><br><span class="line">copyright: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>实现效果如下：<br><img src="http://oyctsei1h.bkt.clouddn.com/%E7%89%88%E6%9D%83%E7%A4%BA%E4%BE%8B.png" alt="img"></p><h2 id="5-添加字数统计与阅读时长"><a href="#5-添加字数统计与阅读时长" class="headerlink" title="5. 添加字数统计与阅读时长"></a>5. 添加字数统计与阅读时长</h2><p>NexT主题默认已经集成了字数统计的功能，只需要在主题的配置文件中打开此功能即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https://github.com/willin/hexo-wordcount</span><br><span class="line">post_wordcount:</span><br><span class="line">  item_text: true</span><br><span class="line">  wordcount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalcount: true</span><br><span class="line">  separated_meta: true</span><br></pre></td></tr></table></figure><p>修改完成之后，重新启动服务，进行预览</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --drafts</span><br></pre></td></tr></table></figure><p>访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 链接，如果出现字数统计和阅读时长失效的情况，一般是因为没有安装 hexo-wordcount 插件，查看 Hexo 插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo --debug</span><br></pre></td></tr></table></figure><p>安装字数统计的插件<br>如果没有安装 hexo-wordcount 插件，先安装该插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure><p><strong>Node 版本 7.6.0 之前,请安装 2.x 版本 (Node.js v7.6.0 and previous) ，安装命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount@2 --save</span><br></pre></td></tr></table></figure><p>安装完成后，重新执行启动服务预览就可以了。</p><p>更为详细的配置可以参考：<a href="https://www.jianshu.com/p/baea8c95e39b" target="_blank" rel="noopener">Hexo添加字数统计、阅读时长</a></p><h2 id="6-添加来必力评论系统"><a href="#6-添加来必力评论系统" class="headerlink" title="6. 添加来必力评论系统"></a>6. 添加来必力评论系统</h2><blockquote><p>参考博客：<a href="http://blog.csdn.net/qwerty200696/article/details/78836421" target="_blank" rel="noopener">hexo博客优化之实现来必力评论功能</a></p></blockquote><p>首先要注册来必力帐号，并获取用户的UID（具体可以看上方的参考博客）。<br>然后打开主题目录的配置文件<code>/next/_config.yml</code>，定位到<code>livere_uid</code>字段，将UID填入即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Support for LiveRe comments system.</span><br><span class="line"># You can get your uid from https://livere.com/insight/myCode (General web site)</span><br><span class="line">#livere_uid: your uid</span><br><span class="line">livere_uid: MTAyMC8zMjk1NS85NTs3</span><br></pre></td></tr></table></figure><p>至此，其他人就可以使用评论系统进行评论。</p><blockquote><p> 效果7-16的设置参考博客：<a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p></blockquote><h2 id="7-修改头像实现旋转"><a href="#7-修改头像实现旋转" class="headerlink" title="7. 修改头像实现旋转"></a>7. 修改头像实现旋转</h2><p>更换头像，打开站点配置文件,找到<code>avatar</code>字段，可以使用网络路径，也可以将头像存放在<code>source/images/</code>中。如果头像是椭圆的，是因为图片不是一个正方形的图片，找到一个宽高像素一样的的图片即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar: /images/head.jpg</span><br></pre></td></tr></table></figure><p>打开<code>\themes\next\source\css\_common\components\sidebar\sidebar-author.styl</code>，在里面添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">.site-author-image &#123;</span><br><span class="line">  display: block;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  padding: $site-author-image-padding;</span><br><span class="line">  max-width: $site-author-image-width;</span><br><span class="line">  height: $site-author-image-height;</span><br><span class="line">  border: $site-author-image-border-width solid $site-author-image-border-color;</span><br><span class="line">  /* 头像圆形 */</span><br><span class="line">  border-radius: 80px;</span><br><span class="line">  -webkit-border-radius: 80px;</span><br><span class="line">  -moz-border-radius: 80px;</span><br><span class="line">  box-shadow: inset 0 -1px 0 #333sf;</span><br><span class="line">  /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束</span><br><span class="line">    (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/</span><br><span class="line"></span><br><span class="line">  /* 鼠标经过头像旋转360度 */</span><br><span class="line">  -webkit-transition: -webkit-transform 1.0s ease-out;</span><br><span class="line">  -moz-transition: -moz-transform 1.0s ease-out;</span><br><span class="line">  transition: transform 1.0s ease-out;</span><br><span class="line">&#125;</span><br><span class="line">img:hover &#123;</span><br><span class="line">  /* 鼠标经过停止头像旋转</span><br><span class="line">  -webkit-animation-play-state:paused;</span><br><span class="line">  animation-play-state:paused;*/</span><br><span class="line">  /* 鼠标经过头像旋转360度 */</span><br><span class="line">  -webkit-transform: rotateZ(360deg);</span><br><span class="line">  -moz-transform: rotateZ(360deg);</span><br><span class="line">  transform: rotateZ(360deg);</span><br><span class="line">&#125;</span><br><span class="line">/* Z 轴旋转动画 */</span><br><span class="line">@-webkit-keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    -webkit-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@-moz-keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    -moz-transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    -moz-transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes play &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line">    transform: rotateZ(0deg);</span><br><span class="line">  &#125;</span><br><span class="line">  100% &#123;</span><br><span class="line">    transform: rotateZ(-360deg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-添加访问量"><a href="#8-添加访问量" class="headerlink" title="8. 添加访问量"></a>8. 添加访问量</h2><p>打开<code>\themes\next\layout\_partials\footer.swig</code>文件,搜索<code>&lt;div class=&quot;copyright&quot;&gt;</code>，在这个div标签前边加上如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>然后再在合适的位置添加如下代码，自己是放在<code>footer.swig</code>文件的末尾，具体显示的位置见博主的博客。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;powered-by&quot;&gt;</span><br><span class="line">&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">  本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>注意：统计访问量有两种不同的方式（自己使用的是uv的方式）</p><ol><li><p>pv的方式，也就是单个用户连续点击n篇文章，记录n次访问量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt;</span><br><span class="line">    本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></li><li><p>uv的方式，单个用户点击n篇文章，只记录1次访问量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt;</span><br><span class="line">  本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure></li></ol><p>添加之后再执行<code>hexo d -g</code>，然后再刷新页面就能看到效果</p><h2 id="9-添加进度条"><a href="#9-添加进度条" class="headerlink" title="9. 添加进度条"></a>9. 添加进度条</h2><p>首先需要查看当前NexT的版本号？<br>如何查看当前NexT主题的版本号呢，打开主题配置文件<code>_config.yml</code>,最下方就显示了当前的版本号。</p><p>版本<code>5.1.3</code>只需要在主题配置文件中找到<code>pace</code>属性，将其修改为<code>true</code>就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Progress bar in the top during page loading.</span><br><span class="line">pace: true</span><br><span class="line"># Themes list:</span><br><span class="line">#pace-theme-big-counter</span><br><span class="line">#pace-theme-bounce</span><br><span class="line">#pace-theme-barber-shop</span><br><span class="line">#pace-theme-center-atom</span><br><span class="line">#pace-theme-center-circle</span><br><span class="line">#pace-theme-center-radar</span><br><span class="line">#pace-theme-center-simple</span><br><span class="line">#pace-theme-corner-indicator</span><br><span class="line">#pace-theme-fill-left</span><br><span class="line">#pace-theme-flash</span><br><span class="line">#pace-theme-loading-bar</span><br><span class="line">#pace-theme-mac-osx</span><br><span class="line">#pace-theme-minimal</span><br><span class="line"># For example</span><br><span class="line"># pace_theme: pace-theme-center-simple</span><br><span class="line">pace_theme: pace-theme-minimal</span><br></pre></td></tr></table></figure><h2 id="10-侧边栏社交小图标设置"><a href="#10-侧边栏社交小图标设置" class="headerlink" title="10. 侧边栏社交小图标设置"></a>10. 侧边栏社交小图标设置</h2><p>打开主题配置文件，搜索<code>social_icons</code>,在<a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">图标库</a>找自己喜欢的小图标，并将名字复制到social_icons属性下，保存即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/bailangsyc</span><br><span class="line">  CSDN: http://blog.csdn.net/bailangsyc?ref=toolbar</span><br><span class="line">  简书: https://www.jianshu.com/u/05c8535250b5</span><br><span class="line">  音乐: http://music.163.com/#/user/home?id=328756156</span><br><span class="line">  #E-Mail: mailto:yourname@gmail.com || envelope</span><br><span class="line">  #Google: https://plus.google.com/yourname || google</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  icons_only: false</span><br><span class="line">  transition: false</span><br><span class="line">  GitHub: github</span><br><span class="line">  csdn: crosshairs</span><br><span class="line">  简书: heartbeat</span><br><span class="line">  音乐: fa-music</span><br></pre></td></tr></table></figure><h2 id="11-添加Rss"><a href="#11-添加Rss" class="headerlink" title="11. 添加Rss"></a>11. 添加Rss</h2><p><img src="http://oyctsei1h.bkt.clouddn.com/Rss.png" alt="img"><br>使用<code>cd</code>进入博客的根目录，执行下方命令安装插件<code>hexo-generate-feed</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure><p>找到博客的配置文件<code>_config.yml</code>,然后在文件末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">plugins: hexo-generate-feed</span><br></pre></td></tr></table></figure><p>然后找到主题的配置文件<code>_config.yml</code>,在rss:的后面加上/atom.xml,注意在冒号后面要加一个空格)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Set rss to false to disable feed link.</span><br><span class="line"># Leave rss as empty to use site&apos;s feed link.</span><br><span class="line"># Set rss to specific value if you have burned your feed already.</span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure><p>在博客根目录执行命令<code>hexo g</code></p><h2 id="12-修改文章内链接文本样式"><a href="#12-修改文章内链接文本样式" class="headerlink" title="12. 修改文章内链接文本样式"></a>12. 修改文章内链接文本样式</h2><p>见本博客文章中的效果：当点击蓝色链接时，颜色变为黄色</p><p>修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@import &quot;post-expand&quot;;</span><br><span class="line">@import &quot;post-collapse&quot;;</span><br></pre></td></tr></table></figure><h2 id="13-修改文章底部的那个带-号的标签"><a href="#13-修改文章底部的那个带-号的标签" class="headerlink" title="13. 修改文章底部的那个带#号的标签"></a>13. 修改文章底部的那个带#号的标签</h2><p>默认的标签文字前边是个<code>#</code>，可以将其修改为如下效果<br><img src="http://oyctsei1h.bkt.clouddn.com/tag.png" alt="img"><br>修改模板<code>/themes/next/layout/_macro/post.swig</code>，搜索 rel=”tag”&gt;#，将 # 换成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;post-tags&quot;&gt;</span><br><span class="line">     &#123;% for tag in post.tags %&#125;</span><br><span class="line">       &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">     &#123;% endfor %&#125;</span><br><span class="line">   &lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="14-在每篇文章末尾统一添加“本文结束”标记"><a href="#14-在每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="14. 在每篇文章末尾统一添加“本文结束”标记"></a>14. 在每篇文章末尾统一添加“本文结束”标记</h2><p><img src="http://oyctsei1h.bkt.clouddn.com/%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0.png" alt="img"><br>在路径<code>\themes\next\layout\_macro</code> 中新建<code>passage-end-tag.swig</code> 文件,并添加以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;-------------本文结束&lt;i class=&quot;fa fa-paw&quot;&gt;&lt;/i&gt;感谢您的阅读-------------&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>接着打开<code>\themes\next\layout\_macro\post.swig</code>文件，在<code>post-body</code>之后， <code>post-footer</code> 之前添加如下画红色部分代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="http://oyctsei1h.bkt.clouddn.com/%E7%BB%93%E6%9D%9F%E6%88%AA%E5%9B%BE.png" alt="img"><br>然后打开主题配置文件<code>_config.yml</code>,在末尾添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><h2 id="15-添加底部分享"><a href="#15-添加底部分享" class="headerlink" title="15. 添加底部分享"></a>15. 添加底部分享</h2><p><img src="http://oyctsei1h.bkt.clouddn.com/share.png" alt="img"><br>在<strong>主题的配置</strong>文件中,将<code>jiathis</code>改为true即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Share</span><br><span class="line"># This plugin is more useful in China, make sure you known how to use it.</span><br><span class="line"># And you can find the use guide at official webiste: http://www.jiathis.com/.</span><br><span class="line"># Warning: JiaThis does not support https.</span><br><span class="line">jiathis: true</span><br><span class="line">  ##uid: Get this uid from http://www.jiathis.com/</span><br></pre></td></tr></table></figure><h2 id="16-修改代码块自定义样式"><a href="#16-修改代码块自定义样式" class="headerlink" title="16. 修改代码块自定义样式"></a>16. 修改<code></code>代码块自定义样式</h2><p>效果如下<br><img src="http://oyctsei1h.bkt.clouddn.com/%E9%BB%84%E8%89%B2%E4%BB%A3%E7%A0%81%E5%9D%97%E6%A0%B7%E5%BC%8F.png" alt="img"><br>打开<code>\themes\next\source\css\_custom\custom.styl</code>,向里面加入如下css样式，即可实现如上效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">code &#123;</span><br><span class="line">    color: #ff7600;</span><br><span class="line">    background: #fbf7f8;</span><br><span class="line">    margin: 2px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-添加友情链接"><a href="#17-添加友情链接" class="headerlink" title="17. 添加友情链接"></a>17. 添加友情链接</h2><blockquote><p>参考博客：<a href="http://blog.csdn.net/wangxw725/article/details/71602256?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">Hexo添加字数统计、阅读时长、友情链接</a><br><img src="http://oyctsei1h.bkt.clouddn.com/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.png" alt="img"><br>在主题配置文件(<code>Blog\themes\next_config.yml</code>)中打开links 开关即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Blog rolls</span><br><span class="line">links_icon: link</span><br><span class="line">links_title: 友情链接</span><br><span class="line">#links_layout: block</span><br><span class="line">links_layout: inline</span><br><span class="line">links:</span><br><span class="line">  #Title: http://example.com/</span><br><span class="line">  刘望舒: http://liuwangshu.cn/</span><br><span class="line">  Gityuan: http://gityuan.com/</span><br><span class="line">  郭霖: http://blog.csdn.net/guolin_blog/</span><br><span class="line">  张鸿洋: http://blog.csdn.net/lmj623565791</span><br><span class="line">  玩Android: http://www.wanandroid.com/tools/bejson</span><br><span class="line">  Google Codelabs: http://clmirror.storage.googleapis.com/gddchina</span><br><span class="line">  小专栏: https://xiaozhuanlan.com/</span><br><span class="line">  时间的朋友: http://51world.win/</span><br></pre></td></tr></table></figure><blockquote><p>注意：添加友情链接后 运行hexo g命令报错。<br>此时，只要将其中一个links_layout属性注掉就可以。<br>links_layout: inline 对应的水平布局，否则友情链接是竖直一列排列</p></blockquote><h2 id="18-博客添加背景动态效果和心心"><a href="#18-博客添加背景动态效果和心心" class="headerlink" title="18. 博客添加背景动态效果和心心"></a>18. 博客添加背景动态效果和心心</h2><blockquote><p>参考博客<a href="http://blog.ynxiu.com/2016/hexo-next-theme-optimize.html" target="_blank" rel="noopener">Hexo+NexT主题配置备忘</a></p></blockquote><p>因为动态背景效果在手机上体验不太好，所以自己只加了小心心的效果。当鼠标左键点击的时候会出现不同颜色的小心心。</p><p>下载<code>js</code>文件<code>love.js</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</span><br></pre></td></tr></table></figure><p>把 <code>js</code> 文件 <code>love.js</code>放在 <code>\themes\next\source\js\src</code> 文件目录下</p><p>更新<code>\themes\next\layout\_layout.swig</code> 文件，在末尾（在前面引用会出现找不到的bug）添加以下<code>js</code> 引入代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="19-hexo文章目录显示的bug"><a href="#19-hexo文章目录显示的bug" class="headerlink" title="19. hexo文章目录显示的bug"></a>19. hexo文章目录显示的bug</h2><blockquote><p>参考博客：<a href="https://github.com/iissnan/hexo-theme-next/issues/2035" target="_blank" rel="noopener">hexo-next为啥文章预览那里我的文章跳转只能点击前面的数字 #2035</a></p></blockquote><p>将主题配置文件中的<code>number</code>属性修改为false即可取消自动编号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Automatically add list number to toc.</span><br><span class="line">number: false</span><br></pre></td></tr></table></figure><blockquote><p>bug描述： hexo会自动为文章生成一个目录，并且会自动编号。<br>这个功能可以在主题配置文件中开启，但是编号以后只点击编号才能跳转到对应位置，点击文字却没有反应。</p></blockquote><p>如下图<br><img src="http://oyctsei1h.bkt.clouddn.com/hexo%E7%9B%AE%E5%BD%95bug.png" alt="img"></p><p>这是<code>hexo 3.4.3</code>的一个bug，只有点击文章目录的编号才能跳转。更新hexo到3.4.4即可解决此bug。</p><p>进入到博客的根目录中，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update hexo</span><br></pre></td></tr></table></figure><p>然后执行<code>hexo version</code>查看hexo的版本号，更新完成即可解决此bug。</p><h2 id="20-修改插入图片的大小"><a href="#20-修改插入图片的大小" class="headerlink" title="20. 修改插入图片的大小"></a>20. 修改插入图片的大小</h2><p>插入手机截图的时候，总是充满容器，可以通过添加css样式文件来控制大小。</p><p>以插入手机截图为例，<br>打开自定义css文件<code>/work/blog-hexo/themes/next/source/css/_custom/custom.styl</code>（如果没有custom.styl，可以自己创建一个）<br>插入以下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.image-size-400&#123;</span><br><span class="line">//表示插入的图片的宽度为 400px</span><br><span class="line">    width: 400px</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文章中的使用方法，示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://oyctsei1h.bkt.clouddn.com/%E8%AE%BE%E7%BD%AE%E6%89%8B%E6%9C%BAip.png&quot; class=&quot;image-size-400&quot; /&gt;</span><br></pre></td></tr></table></figure><h2 id="20-更换Scheme"><a href="#20-更换Scheme" class="headerlink" title="20. 更换Scheme"></a>20. 更换Scheme</h2><p>NexT主题默认有四种主题外观，Scheme的切换可以通过更改 主题配置文件 。搜索 scheme 关键字,就会看到有四行 scheme 的配置，将需要启用的scheme前面的注释<code>#</code>去除即可。</p><p>注意事项<br>但是 scheme 前边一定不要留空格，<code>:</code>必须是英文的，而且后边必须留空格。</p><p>正确配置<br><img src="http://oyctsei1h.bkt.clouddn.com/theme%E6%AD%A3%E7%A1%AE.png" alt="正确配置"></p><p>错误的配置（<code>:</code>后没有空格）<br><img src="http://oyctsei1h.bkt.clouddn.com/%E9%94%99%E8%AF%AF%E9%85%8D%E7%BD%AE1.png" alt="img"></p><p>错误配置（<code>scheme</code>前边留了空格）<br><img src="http://oyctsei1h.bkt.clouddn.com/%E9%94%99%E8%AF%AF%E9%85%8D%E7%BD%AE2.png" alt="img"></p><p>如果<code>scheme</code>前边留了空格，执行<code>hexo g</code>命令，或者启动博客服务时，会报出如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Unhandled rejection Error: ENOENT: no such file or directory, open &apos;C:\github\blog\themes\next\layout\_scripts\schemes\.swig&apos;</span><br><span class="line">    at Error (native)</span><br><span class="line">    at Object.fs.openSync (fs.js:584:18)</span><br><span class="line">    at Object.fs.readFileSync (fs.js:431:33)</span><br><span class="line">    at Object.ret.load (C:\github\blog\node_modules\swig\lib\loaders\filesystem.js:55:15)</span><br><span class="line">    at compileFile (C:\github\blog\node_modules\swig\lib\swig.js:695:31)</span><br><span class="line">    at Object.eval [as tpl] (eval at &lt;anonymous&gt; (C:\github\blog\node_modules\swig\lib\swig.js:498:13), &lt;anonymous&gt;:293:18)</span><br><span class="line">    at compiled [as _compiledSync] (C:\github\blog\node_modules\swig\lib\swig.js:619:18)</span><br><span class="line">    at tryCatcher (C:\github\blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at null._compiled (C:\github\blog\node_modules\bluebird\js\release\method.js:15:34)</span><br><span class="line">    at View.render (C:\github\blog\node_modules\hexo\lib\theme\view.js:29:15)</span><br><span class="line">    at C:\github\blog\node_modules\hexo\lib\hexo\index.js:387:25</span><br><span class="line">    at tryCatcher (C:\github\blog\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at C:\github\blog\node_modules\bluebird\js\release\method.js:15:34</span><br><span class="line">    at RouteStream._read (C:\github\blog\node_modules\hexo\lib\hexo\router.js:134:3)</span><br><span class="line">    at RouteStream.Readable.read (_stream_readable.js:336:10)</span><br><span class="line">    at resume_ (_stream_readable.js:726:12)</span><br><span class="line">    at _combinedTickCallback (node.js:383:13)</span><br><span class="line">    at process._tickCallback (node.js:407:11)</span><br></pre></td></tr></table></figure><h2 id="21-优化加载速度"><a href="#21-优化加载速度" class="headerlink" title="21. 优化加载速度"></a>21. 优化加载速度</h2><p>为了提高网站的加载速度，使用gulp对博文中的js、css、img等文件进行压缩。<br>在博客的根目录执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install gulp -g</span><br><span class="line">$ npm install gulp-minify-css gulp-uglify gulp-htmlmin gulp-htmlclean gulp --save</span><br></pre></td></tr></table></figure><p>然后在根目录中新建文件<code>gulpfile.js</code>，并填入以下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">var minifycss = require(&apos;gulp-minify-css&apos;);</span><br><span class="line">var uglify = require(&apos;gulp-uglify&apos;);</span><br><span class="line">var htmlmin = require(&apos;gulp-htmlmin&apos;);</span><br><span class="line">var htmlclean = require(&apos;gulp-htmlclean&apos;);</span><br><span class="line">// 压缩 public 目录 css</span><br><span class="line">gulp.task(&apos;minify-css&apos;, function() &#123;</span><br><span class="line">    return gulp.src(&apos;./public/**/*.css&apos;)</span><br><span class="line">        .pipe(minifycss())</span><br><span class="line">        .pipe(gulp.dest(&apos;./public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public 目录 html</span><br><span class="line">gulp.task(&apos;minify-html&apos;, function() &#123;</span><br><span class="line">  return gulp.src(&apos;./public/**/*.html&apos;)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">         removeComments: true,</span><br><span class="line">         minifyJS: true,</span><br><span class="line">         minifyCSS: true,</span><br><span class="line">         minifyURLs: true,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(&apos;./public&apos;))</span><br><span class="line">&#125;);</span><br><span class="line">// 压缩 public/js 目录 js</span><br><span class="line">gulp.task(&apos;minify-js&apos;, function() &#123;</span><br><span class="line">    return gulp.src(&apos;./public/**/*.js&apos;)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(&apos;./public&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">// 执行 gulp 命令时执行的任务</span><br><span class="line">gulp.task(&apos;default&apos;, [</span><br><span class="line">    &apos;minify-html&apos;,&apos;minify-css&apos;,&apos;minify-js&apos;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>生成博文是执行<code>hexo g &amp;&amp; gulp</code>就会根据<code>gulpfile.js</code>中的配置，对<code>public</code>目录中的静态资源文件进行压缩。</p><h2 id="22-博文置顶"><a href="#22-博文置顶" class="headerlink" title="22. 博文置顶"></a>22. 博文置顶</h2><p>打开博客的根目录，将文件 <code>node_modules/hexo-generator-index/lib/generator.js</code>中的代码替换为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&apos;use strict&apos;;</span><br><span class="line">var pagination = require(&apos;hexo-pagination&apos;);</span><br><span class="line">module.exports = function(locals)&#123;</span><br><span class="line">  var config = this.config;</span><br><span class="line">  var posts = locals.posts;</span><br><span class="line">    posts.data = posts.data.sort(function(a, b) &#123;</span><br><span class="line">        if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义</span><br><span class="line">            if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排</span><br><span class="line">            else return b.top - a.top; // 否则按照top值降序排</span><br><span class="line">        &#125;</span><br><span class="line">        else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        else return b.date - a.date; // 都没定义按照文章日期降序排</span><br><span class="line">    &#125;);</span><br><span class="line">  var paginationDir = config.pagination_dir || &apos;page&apos;;</span><br><span class="line">  return pagination(&apos;&apos;, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [&apos;index&apos;, &apos;archive&apos;],</span><br><span class="line">    format: paginationDir + &apos;/%d/&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后写文章的时候，添加 <code>top</code>字段即可，数值越大文章越考前。例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">title: 优秀博主合集</span><br><span class="line">tags: Android</span><br><span class="line">categories: 移动开发</span><br><span class="line">photos:</span><br><span class="line">date: 2018-01-30 17:27:39</span><br><span class="line">updated:</span><br><span class="line">copyright: true</span><br><span class="line">top: 100</span><br></pre></td></tr></table></figure><blockquote><p>注意：必须重启本地服务才会生效。</p></blockquote><h2 id="23-去掉图片默认的边框"><a href="#23-去掉图片默认的边框" class="headerlink" title="23.去掉图片默认的边框"></a>23.去掉图片默认的边框</h2><p>默认插入的图片带有边框</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% img http://oyctsei1h.bkt.clouddn.com/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png 600 350 观察者模式%&#125;</span><br></pre></td></tr></table></figure><p><img src="http://oyctsei1h.bkt.clouddn.com/%E5%B8%A6%E8%BE%B9%E6%A1%86.png" alt="img"><br>修改不带边框后的效果：<br><img src="http://oyctsei1h.bkt.clouddn.com/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"><br>显然不带边框的时候比较好看些，那么如何将默认的边框去掉呢？<br>自己在<a href="https://github.com/iissnan/hexo-theme-next/issues/963" target="_blank" rel="noopener">hexo next主题去掉图片边框</a>这篇文章中找到了解决办法。将Next主题/themes/next/source/css/_common/components/post/post-expand.styl文件中的img的border的值修改为<code>none</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//将border的值修改为none即可去掉边框，默认值为 1px solid $gray-lighter</span><br><span class="line">  img &#123;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    margin: auto;</span><br><span class="line">    padding: 3px;</span><br><span class="line">    border: none; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="24-添加Valine评论系统"><a href="#24-添加Valine评论系统" class="headerlink" title="24. 添加Valine评论系统"></a>24. 添加<code>Valine</code>评论系统</h2><p>本篇博客的第六条已经总结了如何为博客添加来必力评论系统， 来必力是韩国人开发的评论系统，一方面国内加载速度慢，另一方面评论需要登录，因此自己将博客的评论系统更换为<code>Valine</code>。有关<code>Valine</code>可以参考<a href="https://valine.js.org/" target="_blank" rel="noopener">官方文档</a>与原作者的博客：<a href="https://ioliu.cn/2017/add-valine-comments-to-your-blog/" target="_blank" rel="noopener">Valine – 一款极简的评论系统</a>。</p><p>为<code>Hexo</code>博客<code>Next</code>主题添加<code>Valine</code>系统可以参考博客<a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a>。</p><p>主要有以下步骤：</p><ul><li>到<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud官网</a>注册一个帐号</li><li>登录<code>LeanCloud</code>帐号，创建一个app应用，名字随便写</li><li>将<code>App Id</code> 和 <code>App Key</code> 配置到主题的配置文件<code>valine</code>字段下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: your app id # your leancloud application appid</span><br><span class="line">  appkey: your app key  # your leancloud application appkey</span><br><span class="line">  notify: false # mail notifier , https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # Verification code</span><br><span class="line">  placeholder: ヾﾉ≧∀≦)o来啊，快活啊! </span><br><span class="line">  avatar: mm # gravatar style</span><br><span class="line">  guest_info: nick,mail,link # custom comment header</span><br><span class="line">  pageSize: 10 # pagination size</span><br></pre></td></tr></table></figure><p><strong>注意：不同版本的主题app_id 和 app_key 这两个字段名是不一样的，复制的时候一定要看清楚。</strong>5.1.3版本字段名称是：<code>appid</code> 、<code>appkey</code>， 6.0.1版本的字段名称是：<code>app_id</code>、<code>app_key</code>。</p>]]></content>
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
            <tag> hexo </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序分析</title>
      <link href="/2017/08/28/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
      <url>/2017/08/28/%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>在计算机科学中，程序分析指的是对计算机程序进行自动分析的过程，包括程序正确性，健壮性，安全性以及活跃性的分析。程序分析主要关注于两个方面：程序优化以及程序正确性。前者着眼于提升程序的性能并减少资源的使用，而后者着重于确保程序行为就是它应该有的行为。</p><p>程序分析既可以在不执行程序的情况下进行（即 静态分析），也能在运行时进行（即动态分析），或者结合两者来进行。</p><h2 id="静态程序分析-Static-program-analysis"><a href="#静态程序分析-Static-program-analysis" class="headerlink" title="静态程序分析 (Static program analysis)"></a>静态程序分析 (Static program analysis)</h2><p>静态分析能够在程序开发阶段就发现程序的缺陷，而这些缺陷相比于测试阶段所发现的缺陷更加易于修改，因为静态分析指向的是缺陷的根源。而由于静态分析的计算不确定性，这种机制太宽松且不完整。静态分析尽管有一定的局限性，但首先能够减少缺陷数量，其次对低缺陷提供了有力的保证。</p><h3 id="控制流分析-Control-flow-analysis"><a href="#控制流分析-Control-flow-analysis" class="headerlink" title="控制流分析 (Control-flow analysis)"></a>控制流分析 (Control-flow analysis)</h3><p>控制流分析的目的是获取程序执行过程中的不同位置哪些函数可以被调用的相关信息。收集后的信息可以用控制流图（control flow graph CFG）来进行表示，其中的结点就是程序的某一段指令，而边代表的就是控制流。通过识别代码块以及循环结构，控制流图 CFG 成为了编译器优化的一个入手点。</p><h3 id="数据流分析-Data-flow-analysis"><a href="#数据流分析-Data-flow-analysis" class="headerlink" title="数据流分析 (Data-flow analysis)"></a>数据流分析 (Data-flow analysis)</h3><p>数据流分析是一项用于收集程序每个位置处的值以及它们如何随着时间变化相关信息的技术。这项技术通常被用于优化代码。其中最有名的就是 Taint checking，它假设所有由用户提供数据的变量都是不安全的，然后防止这些数据被使用，直到被脱毒处理。这项技术通常用于预防 SQL 注入攻击。</p><h3 id="抽象解释-Abstract-interpretation"><a href="#抽象解释-Abstract-interpretation" class="headerlink" title="抽象解释 (Abstract interpretation)"></a>抽象解释 (Abstract interpretation)</h3><p>抽象解释允许对一个程序的可能执行进行信息抽取，而不用实际地执行程序。编译器可以利用这些信息来寻找可能的优化或证明程序不存在某一类的bug。</p><h3 id="类型系统-Type-systems"><a href="#类型系统-Type-systems" class="headerlink" title="类型系统 (Type systems)"></a>类型系统 (Type systems)</h3><p>类型系统将类型绑定到满足特定需求的程序上。其目的是为了挑选出一个语言程序的子集，而这个子集被认为在某个性质上是正确的。</p><ul><li>类型检查 （Type checking）——验证程序是否能够被类型系统所接受</li></ul><p>类型检查在编程中被用于约束程序对象的使用及其行为。通常由编译器或解释器来完成。类型检查同样有利于预防缺陷，确保一个有符号数不会被赋给一个无符号变量。类型检查可以被静态地进行（即 编译时），动态地进行（即 运行时），或二者结合来进行。</p><h3 id="效果系统-（Effect-systems）"><a href="#效果系统-（Effect-systems）" class="headerlink" title="效果系统 （Effect systems）"></a>效果系统 （Effect systems）</h3><p>效果系统是一个形式化的系统，用于研究执行程序所具有的效果。一个效果包括完成了什么以及什么将要被完成，通常指效果类型和位置。</p><h3 id="模型检测-（model-checking）"><a href="#模型检测-（model-checking）" class="headerlink" title="模型检测 （model checking）"></a>模型检测 （model checking）</h3><p>模型检测指的是寻找一种严格的、形式化的并且自动化的方法来验证某个给定模型（model）是否符合其给定规格（specification）的问题。由于系统具有有限状态的性质，而且模型和系统都可以使用逻辑公式（logical formulas）来进行表示，因而可以使用高效的算法来验证系统是否违反了某些规格。</p><h2 id="动态程序分析-（Dynamic-program-analysis）"><a href="#动态程序分析-（Dynamic-program-analysis）" class="headerlink" title="动态程序分析 （Dynamic program analysis）"></a>动态程序分析 （Dynamic program analysis）</h2><p>动态分析可以利用程序运行时的相关信息来提升分析的精度，并提供运行时的保护，但是一次只能分析程序的单个执行，并且因为运行时的检查，会降低程序的性能。</p><h3 id="测试（Testing）"><a href="#测试（Testing）" class="headerlink" title="测试（Testing）"></a>测试（Testing）</h3><p>软件被测试用于保证其质量并确保其如预期所料、以可靠的方式运行，并且不和其他具有相关功能的软件发生冲突。进行测试，就是执行一个带有输入的程序，然后对其行为以及产生的输出进行评估的过程。即使没有特定的安全需求，也要进行额外的安全测试，以此保证攻击者无法篡改软件并偷取信息，中断程序的正常执行或利用它作为枢轴攻击它的用户。</p><h3 id="监视-（Monitoring）"><a href="#监视-（Monitoring）" class="headerlink" title="监视 （Monitoring）"></a>监视 （Monitoring）</h3><p>程序监视记录有关程序的各种信息，比如 资源占用，事件与交互的情况，因而可以用于审查来发现程序的异常行为，进一步可以精确地定位到异常行为的根源。另外，它可以用于安全审计（Security audits）。自动的程序监视有时候被称为运行时验证 （Runtime Verification）。</p><h3 id="程序切片-（Program-slicing）"><a href="#程序切片-（Program-slicing）" class="headerlink" title="程序切片 （Program slicing）"></a>程序切片 （Program slicing）</h3><p>对于一个给定的程序行为子集，程序切片是对程序不断裁剪，直到产生一个仍能产生所选择行为的最小形式。这个裁剪后的程序就被称为是一个“切片”，它是原始程序对于该特定行为子集的如实表达的部分。通常，寻找一个切片是一个不可解问题，但通过将变量集合值作为目标行为子集的方式，利用数据流分析，可以获取到近似的切片。这些切片通常在调试过程中被开发者用于定位错误的源头。</p>]]></content>
      
      <categories>
          
          <category> 程序分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS 设置静态 IP</title>
      <link href="/2016/12/20/CentOS-%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
      <url>/2016/12/20/CentOS-%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/</url>
      <content type="html"><![CDATA[<h1 id="CentOs-设置静态-IP"><a href="#CentOs-设置静态-IP" class="headerlink" title="CentOs 设置静态 IP"></a>CentOs 设置静态 IP</h1><h2 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h2><ol><li>修改网卡配置<code>/etc/sysconfig/network-scripts/ifcfg-eth0</code>，设置静态ip</li><li>修改网关配置<code>/etc/sysconfig/network</code>，设置网关地址</li><li>设置DNS服务器<code>/etc/resolv.conf</code></li><li>重启网卡 <code>sudo /etc/init.d/network restart</code></li></ol><h2 id="修改网卡配置"><a href="#修改网卡配置" class="headerlink" title="修改网卡配置　"></a>修改网卡配置　</h2><p>编辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DEVICE=eth0</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">IPV4_FAILURE_FATAL=yes</span><br><span class="line">IPV6INIT=no</span><br><span class="line">NAME=&quot;System eth0&quot;</span><br><span class="line">USERCTL=no</span><br><span class="line">IPADDR=172.21.0.16</span><br><span class="line">DNS2=172.21.1.2</span><br><span class="line">DNS1=172.21.1.1</span><br></pre></td></tr></table></figure><ul><li>DEVICE=eth0 #描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0</li><li>BOOTPROTO=static #设置网卡获得ip地址的方式，可能的选项为static，dhcp或bootp，分别对应静态指定的 ip地址，通过dhcp协议获得的ip地址，通过bootp协议获得的ip地址</li><li>BROADCAST=192.168.0.255 #对应的子网广播地址</li><li><p>HWADDR=00:07:E9:05:E8:B4 #对应的网卡物理地址</p></li><li><p>IPADDR=12.168.0.33 #如果设置网卡获得 ip地址的方式为静态指定，此字段就指定了网卡对应的ip地址</p></li><li>NETMASK=255.255.255.0 #网卡对应的网络掩码</li><li>NETWORK=192.168.0.0 #网卡对应的网络地址</li></ul><h2 id="修改网关配置"><a href="#修改网关配置" class="headerlink" title="修改网关配置"></a>修改网关配置</h2><p>编辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/sysconfig/network</span><br></pre></td></tr></table></figure><p>　<br>修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NETWORKING=yes</span><br><span class="line">AHOSTNAME=www</span><br><span class="line">GATEWAY=172.21.0.1</span><br></pre></td></tr></table></figure><ul><li>NETWORKING=yes(表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动)</li><li>HOSTNAME=centos(设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应)</li><li>GATEWAY=192.168.0.1(设置本机连接的网关的IP地址。)</li></ul><blockquote><p>我在修改这里打开编辑时前三项已经默认有了所以只增加了GATEWAY</p></blockquote><h2 id="修改DNS-配置"><a href="#修改DNS-配置" class="headerlink" title="修改DNS 配置"></a>修改DNS 配置</h2><p>编辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>修改后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">; generated by /sbin/dhclient-script</span><br><span class="line">nameserver 172.21.1.1</span><br><span class="line">nameserver 172.21.1.2</span><br></pre></td></tr></table></figure><p>nameserver　即是DNS服务器ＩＰ地址，第一个是首选，第二个是备用。</p><h2 id="重启网络服务"><a href="#重启网络服务" class="headerlink" title="重启网络服务"></a>重启网络服务</h2><p>执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service network restart</span><br></pre></td></tr></table></figure><p>或 　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo /etc/init.d/network restart</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 服务器管理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Learning.Groovy</title>
      <link href="/2016/07/10/Learning-Groovy/"/>
      <url>/2016/07/10/Learning-Groovy/</url>
      <content type="html"><![CDATA[<h1 id="Learning-Groovy"><a href="#Learning-Groovy" class="headerlink" title="Learning Groovy"></a>Learning Groovy</h1><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>Step:</p><ol><li>Downloar binary or installer from Groovy official site</li><li>Extract binary archive file or Install with Installer</li><li>Open a terminal, type <code>groovy --version</code> to check if groovy has been installed successfully</li></ol><p>problem:</p><ol><li>If you has set <code>CLASSPATH</code> enviroment variable, there will be some odd exception. <blockquote><p>solution: You need to remove CLASSAPATH enviroment variable.</p></blockquote></li></ol>]]></content>
      
      
    </entry>
    
    <entry>
      <title>统计代码行数</title>
      <link href="/2016/07/06/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/"/>
      <url>/2016/07/06/%E7%BB%9F%E8%AE%A1%E4%BB%A3%E7%A0%81%E8%A1%8C%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="统计代码行数"><a href="#统计代码行数" class="headerlink" title="统计代码行数"></a>统计代码行数</h1><h2 id="命令如下"><a href="#命令如下" class="headerlink" title="命令如下"></a>命令如下</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find .  -name &quot;*.java&quot; | xargs wc -l</span><br></pre></td></tr></table></figure><h2 id="命令分解"><a href="#命令分解" class="headerlink" title="命令分解"></a>命令分解</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name &quot;.java&quot;</span><br></pre></td></tr></table></figure><blockquote><p>这一步，是找出当前目录子目录下所有的.java文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xargs wc -l</span><br></pre></td></tr></table></figure><p><code>xargs</code> 是将前一步一系列的.java文件分块，一个个传给<code>wc</code>命令，<code>wc -l</code> 命令用于统计一个文件的行数</p><h2 id="多个后缀名的文件"><a href="#多个后缀名的文件" class="headerlink" title="多个后缀名的文件"></a>多个后缀名的文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . -name &quot;*.m&quot; -or -name &quot;*.mm&quot; -or -name &quot;*.cpp&quot; -or -name &quot;*.h&quot; -or -name &quot;*.rss&quot; | xargs wc -l</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>其中后缀名的双引号不用也可以。</p>]]></content>
      
      
        <tags>
            
            <tag> 实用命令 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>log4j-原理</title>
      <link href="/2016/05/21/log4j-%E5%8E%9F%E7%90%86/"/>
      <url>/2016/05/21/log4j-%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="log4j-1-x-原理"><a href="#log4j-1-x-原理" class="headerlink" title="log4j 1.x 原理"></a>log4j 1.x 原理</h2><blockquote><p>log4j 2.x在配置方式方式更加灵活，功能更强大，速度也有所提升，但是也更复杂了，针对大部分中小项目的话，简单实用的1.x系列就足够用了。</p></blockquote><h3 id="log4j-组成"><a href="#log4j-组成" class="headerlink" title="log4j 组成"></a>log4j 组成</h3><ul><li><p>日志信息的优先级</p><ul><li>ERROR</li><li>WARN</li><li>INFO</li><li>DEBUG  </li></ul></li><li><p>日志信息的输出目的地</p><ul><li>控制台</li><li>文件  </li></ul></li><li><p>日志信息的输出格式</p></li></ul><h3 id="参看-log4j-类图"><a href="#参看-log4j-类图" class="headerlink" title="参看 log4j 类图"></a>参看 log4j 类图</h3><p><img src="/img/log4j_class.jpg" alt="alt log4j class digram"></p><ul><li><p>Logger - 日志写出器，供程序员输出日志信息 </p></li><li><p>Appender - 日志目的地，把格式化好的日志信息输出到指定的地方去 </p><ul><li>ConsoleAppender - 目的地为控制台的 Appender </li><li><p>FileAppender - 目的地为文件的 Appender </p><ul><li>RollingFileAppender - 目的地为大小受限的文件的 Appender </li></ul></li></ul></li><li><p>Layout - 日志格式化器，用来把程序员的 logging request 格式化成字符串 </p><ul><li>PatternLayout - 用指定的 pattern 格式化 logging request 的 Layout</li></ul></li></ul><h2 id="log4j-配置"><a href="#log4j-配置" class="headerlink" title="log4j 配置"></a>log4j 配置</h2><h3 id="两种配置文件："><a href="#两种配置文件：" class="headerlink" title="两种配置文件："></a>两种配置文件：</h3><ul><li>log4j.xml</li><li>log4j.properties</li></ul><blockquote><p>也可以直接用代码设置相关配置</p></blockquote><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><ul><li>配置 logger</li><li>配置 appender</li><li>配置 layout</li></ul><h3 id="配置-logger"><a href="#配置-logger" class="headerlink" title="配置 logger"></a>配置 logger</h3><p>配置根Logger，其语法为：</p><pre><code>log4j.rootLogger = [ level ] , appenderName, appenderName, …</code></pre><p>其中，level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。</p><p>Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。</p><p>比如在这里定 义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。 appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。</p><h3 id="配置-Appender"><a href="#配置-Appender" class="headerlink" title="配置 Appender"></a>配置 Appender</h3><pre><code>log4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.option = valueN</code></pre><p>Log4j提供的appender有以下几种：</p><ul><li>org.apache.log4j.ConsoleAppender（控制台）， </li><li>org.apache.log4j.FileAppender（文件）， </li><li>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件）</li><li>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件）</li><li>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）</li></ul><h3 id="配置-layout"><a href="#配置-layout" class="headerlink" title="配置 layout"></a>配置 layout</h3><pre><code>log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class log4j.appender.appenderName.layout.option1 = value1 … log4j.appender.appenderName.layout.option = valueN</code></pre><h4 id="Log4j提供的layout有以下几种："><a href="#Log4j提供的layout有以下几种：" class="headerlink" title="Log4j提供的layout有以下几种："></a>Log4j提供的layout有以下几种：</h4><ul><li>org.apache.log4j.HTMLLayout（以HTML表格形式布局）</li><li>org.apache.log4j.PatternLayout（可以灵活地指定布局模式）</li><li>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） </li><li>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</li></ul><h4 id="Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下："><a href="#Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下：" class="headerlink" title="Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下："></a>Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下：</h4><pre><code>%m  |   输出代码中指定的消息 %p  |   输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL %r  |   输出自应用启动到输出该log信息耗费的毫秒数 %c  |   输出所属的类目，通常就是所在类的全名 %t  |   输出产生该日志事件的线程名 %n  |   输出一个回车换行符，Windows平台为“rn”，Unix平台为“n” %d  |   输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm : ss,SSS}，输出类似：2002年10月18日 22：10：28，921 %l  |   输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)</code></pre>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>log4j-使用</title>
      <link href="/2016/05/21/log4j-%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/05/21/log4j-%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ul><li>获取logger</li><li>读取配置文件</li><li>插入记录信息</li></ul><h3 id="获取-logger"><a href="#获取-logger" class="headerlink" title="获取 logger"></a>获取 logger</h3><p>使用Log4j，第一步就是获取日志记录器，这个记录器将负责控制日志信息。其语法为： </p><pre><code>public static Logger getLogger( String name)</code></pre><p>通过指定的名字获得记录器，如果必要的话，则为这个名字创建一个新的记录器。Name一般取本类的名字，比如： </p><pre><code>public static Logger logger = Logger.getLogger ( Testlog4j.class.getName () )</code></pre><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>当获得了日志记录器之后，第二步将配置Log4j环境，其语法为：</p><pre><code>BasicConfigurator.configure ()//自动快速地使用缺省Log4j环境PropertyConfigurator.configure ( String configFilename)//读取使用Java的 porperties 文件编写的配置文件。 DOMConfigurator.configure ( String filename )//读取XML形式的配置文件。</code></pre><h3 id="插入记录信息（格式化日志信息）"><a href="#插入记录信息（格式化日志信息）" class="headerlink" title="插入记录信息（格式化日志信息）"></a>插入记录信息（格式化日志信息）</h3><pre><code>Logger.debug ( Object message ) ; Logger.info ( Object message ) ; Logger.warn ( Object message ) ;Logger.error ( Object message ) ;</code></pre><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="HelloLog4j-java"><a href="#HelloLog4j-java" class="headerlink" title="HelloLog4j.java"></a>HelloLog4j.java</h3><pre><code>import org.apache.log4j.Logger;public class HelloLog4j {    private static Logger logger = Logger.getLogger(HelloLog4j.class);    /**     * @param args     */    public static void main(String[] args) {        // System.out.println(&quot;This is println message.&quot;);        // 记录debug级别的信息        logger.debug(&quot;This is debug message.&quot;);        // 记录info级别的信息        logger.info(&quot;This is info message.&quot;);        // 记录error级别的信息        logger.error(&quot;This is error message.&quot;);    }}</code></pre><h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><pre><code>#可以设置级别：debug&gt;info&gt;error #debug：显示debug、info、error #info：显示info、error #error：只error log4j.rootLogger=debug,appender1 #log4j.rootLogger=info,appender1 #log4j.rootLogger=error,appender1 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #样式为TTCCLayout log4j.appender.appender1.layout=org.apache.log4j.TTCCLayout</code></pre>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>log4j-配置模板</title>
      <link href="/2016/05/21/log4j-%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/"/>
      <url>/2016/05/21/log4j-%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF/</url>
      <content type="html"><![CDATA[<h3 id="输出为文本文件或HTML文件"><a href="#输出为文本文件或HTML文件" class="headerlink" title="输出为文本文件或HTML文件"></a>输出为文本文件或HTML文件</h3><pre><code>#设置级别： log4j.rootLogger=debug,appender1 #输出到文件(这里默认为追加方式) log4j.appender.appender1=org.apache.log4j.FileAppender #设置文件输出路径 #【1】文本文件 #log4j.appender.appender1.File=c:/Log4JDemo02.log #【2】HTML文件 log4j.appender.appender1.File=c:/Log4JDemo02.html #设置文件输出样式 #log4j.appender.appender1.layout=org.apache.log4j.TTCCLayout log4j.appender.appender1.layout=org.apache.log4j.HTMLLayout</code></pre><h3 id="输出为文本文件或HTML文件-多个目的地"><a href="#输出为文本文件或HTML文件-多个目的地" class="headerlink" title="输出为文本文件或HTML文件 多个目的地"></a>输出为文本文件或HTML文件 多个目的地</h3><pre><code>#设置级别和多个目的地 log4j.rootLogger=debug,appender1,appender2 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.TTCCLayout #输出到文件(这里默认为追加方式) log4j.appender.appender2=org.apache.log4j.FileAppender #设置文件输出路径 #【1】文本文件 #log4j.appender.appender2.File=c:/Log4JDemo02.log #【2】HTML文件 log4j.appender.appender2.File=c:/Log4JDemo02.html #设置文件输出样式 #log4j.appender.appender2.layout=org.apache.log4j.TTCCLayout log4j.appender.appender2.layout=org.apache.log4j.HTMLLayout</code></pre><h3 id="SimpleLayout样式"><a href="#SimpleLayout样式" class="headerlink" title="SimpleLayout样式"></a>SimpleLayout样式</h3><pre><code>#设置级别和目的地 log4j.rootLogger=debug,appender1 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.SimpleLayout</code></pre><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><pre><code>DEBUG - This is debug message. INFO - This is info message. ERROR - This is error message.</code></pre><h3 id="自定义样式"><a href="#自定义样式" class="headerlink" title="自定义样式"></a>自定义样式</h3><pre><code>#设置级别和目的地 log4j.rootLogger=debug,appender1 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.PatternLayout #自定义样式 # %r 时间 0 # %t 方法名 main # %p 优先级 DEBUG/INFO/ERROR # %c 所属类的全名(包括包名) # %l 发生的位置，在某个类的某行 # %m 输出代码中指定的讯息，如log(message)中的message # %n 输出一个换行 log4j.appender.appender1.layout.ConversionPattern=%r [%t] [%p] - %c -%l -%m%n</code></pre><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><pre><code>0 [main] [DEBUG] - com.coderdream.log4j.HelloLog4j -com.coderdream.log4j.HelloLog4j.main(HelloLog4j.java:16) -This is debug message. 31 [main] [INFO] - com.coderdream.log4j.HelloLog4j -com.coderdream.log4j.HelloLog4j.main(HelloLog4j.java:18) -This is info message. 31 [main] [ERROR] - com.coderdream.log4j.HelloLog4j -com.coderdream.log4j.HelloLog4j.main(HelloLog4j.java:20) -This is error message.</code></pre><h3 id="多目的地、自定义样式"><a href="#多目的地、自定义样式" class="headerlink" title="多目的地、自定义样式"></a>多目的地、自定义样式</h3><pre><code>#设置级别和目的地 log4j.rootLogger=debug,appender1,appender2 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.PatternLayout #自定义样式 # %r 时间 0 # %t 方法名 main # %p 优先级 DEBUG/INFO/ERROR # %c 所属类的全名(包括包名) # %l 发生的位置，在某个类的某行 # %m 输出代码中指定的讯息，如log(message)中的message # %n 输出一个换行符号 log4j.appender.appender1.layout.ConversionPattern=[%d{yy/MM/dd HH:mm:ss:SSS}][%C-%M] %m%n #输出到文件(这里默认为追加方式) log4j.appender.appender2=org.apache.log4j.FileAppender #设置文件输出路径 #【1】文本文件 log4j.appender.appender2.File=c:/Log4JDemo06.log #设置文件输出样式 log4j.appender.appender2.layout=org.apache.log4j.PatternLayout log4j.appender.appender2.layout.ConversionPattern=[%d{HH:mm:ss:SSS}][%C-%M] -%m%n</code></pre><h3 id="设置-特定包的级别和目的地-企业应用"><a href="#设置-特定包的级别和目的地-企业应用" class="headerlink" title="设置 特定包的级别和目的地[企业应用]"></a>设置 特定包的级别和目的地[企业应用]</h3><pre><code>#省略根，只设置特定包的级别和目的地 log4j.logger.com.coderdream.log4j=debug,appender1 log4j.logger.com.coderdream.log4jDao=info,appender1,appender2 #输出到控制台 log4j.appender.appender1=org.apache.log4j.ConsoleAppender #设置输出样式 log4j.appender.appender1.layout=org.apache.log4j.PatternLayout #自定义样式 # %r 时间 0 # %t 方法名 main # %p 优先级 DEBUG/INFO/ERROR # %c 所属类的全名(包括包名) # %l 发生的位置，在某个类的某行 # %m 输出代码中指定的讯息，如log(message)中的message # %n 输出一个换行符号 log4j.appender.appender1.layout.ConversionPattern=[%d{yy/MM/dd HH:mm:ss:SSS}][%C-%M] %m%n #输出到文件(这里默认为追加方式) log4j.appender.appender2=org.apache.log4j.FileAppender #设置文件输出路径 #【1】文本文件 log4j.appender.appender2.File=c:/Log4JDemo07_Dao.log#设置文件输出样式 log4j.appender.appender2.layout=org.apache.log4j.PatternLayout log4j.appender.appender2.layout.ConversionPattern=[%d{HH:mm:ss:SSS}][%C-%M] -%m%n</code></pre><h3 id="log4j-xml的配置方式"><a href="#log4j-xml的配置方式" class="headerlink" title="log4j.xml的配置方式"></a>log4j.xml的配置方式</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt; &lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;appender1&quot; class=&quot;org.apache.log4j.RollingFileAppender&quot;&gt; &lt;param name=&quot;File&quot; value=&quot;logfile08.html&quot; /&gt; &lt;param name=&quot;MaxFileSize&quot; value=&quot;1MB&quot; /&gt; &lt;param name=&quot;MaxBackupIndex&quot; value=&quot;5&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.HTMLLayout&quot;&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;appender1&quot; /&gt; &lt;/root&gt; &lt;/log4j:configuration&gt;</code></pre><h2 id="为了提高效率，可以在写日志前增加判断："><a href="#为了提高效率，可以在写日志前增加判断：" class="headerlink" title="为了提高效率，可以在写日志前增加判断："></a>为了提高效率，可以在写日志前增加判断：</h2><pre><code>// 记录debug级别的信息 if (logger.isDebugEnabled()) { logger.debug(&quot;This is debug message from Dao.&quot;); } // 记录info级别的信息 if (logger.isInfoEnabled()) { logger.info(&quot;This is info message from Dao.&quot;); } // 记录error级别的信息 logger.error(&quot;This is error message from Dao.&quot;);</code></pre>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码模板 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人简历</title>
      <link href="/2016/05/10/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
      <url>/2016/05/10/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
      <content type="html"><![CDATA[<h2 id="教育经历"><a href="#教育经历" class="headerlink" title="教育经历"></a>教育经历</h2><h3 id="本科"><a href="#本科" class="headerlink" title="本科"></a>本科</h3><p>东华大学 (2011.09 - 2015.07) </p><p>专业： 软件工程</p><p><strong>绩点 4.1   专业排名 2／60</strong></p><h4 id="获奖情况"><a href="#获奖情况" class="headerlink" title="获奖情况"></a>获奖情况</h4><ul><li>东华大学奖学金 (2013、2014)</li><li>校三好学生 (2013、2014)</li><li>桑麻奖学 (2013)</li><li>东软奖学金 (2014)</li><li>上海市优秀毕业生 (2015)</li></ul><h3 id="硕士"><a href="#硕士" class="headerlink" title="硕士"></a>硕士</h3><p>华东师范大学 (2015.09 - 2018.07)</p><p>专业： 软件工程</p><p>研究方向： 形式化方法、逆向工程</p><p>所属实验室：国家可信嵌入式软件工程研究中心</p><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><ul><li><p>MIPS 处理器多级流水线仿真 （2016.05）</p></li><li><p>Intel 386 指令集反汇编引擎、中间代码生成工具（2016.03 - 2016.05）</p></li><li><p>MIPS 指令集反汇编引擎（2016.03 - 2016.04）</p></li><li><p>360企业安全产品天擎6.0 （2014.11 - 2015.02）</p></li></ul><h2 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h2><h3 id="奇虎360-（2014-11-2015-02）"><a href="#奇虎360-（2014-11-2015-02）" class="headerlink" title="奇虎360 （2014.11 - 2015.02）"></a>奇虎360 （2014.11 - 2015.02）</h3><ul><li>Java开发、PHP开发、前端开发    </li><li>参与项目：企业安全产品天擎6.0</li></ul><h3 id="上海创多软件股份有限公司-（2014-07-2014-11）"><a href="#上海创多软件股份有限公司-（2014-07-2014-11）" class="headerlink" title="上海创多软件股份有限公司 （2014.07 - 2014.11）"></a>上海创多软件股份有限公司 （2014.07 - 2014.11）</h3><ul><li>Java开发、前端开发</li><li>参与项目：在线英语阅读学习平台</li></ul><h3 id="To-be-continue…"><a href="#To-be-continue…" class="headerlink" title="To be continue…"></a>To be continue…</h3>]]></content>
      
      
        <tags>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>翻译：MiniSAT用户指南</title>
      <link href="/2016/04/03/%E7%BF%BB%E8%AF%91%EF%BC%9AMiniSAT%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"/>
      <url>/2016/04/03/%E7%BF%BB%E8%AF%91%EF%BC%9AMiniSAT%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/</url>
      <content type="html"><![CDATA[<blockquote><p>源网页<a href="http://www.dwheeler.com/essays/minisat-user-guide.html" target="_blank" rel="noopener"><br>MiniSAT User Guide: How to use the MiniSAT SAT Solver</a></p></blockquote><p>MiniSat是一个面向研究人员与开发人员所开发的微型、开源的布尔可满足性问题求解器(<em>Boolean satisfiability problem solver</em>)。它发布在 <em>MIT license</em> 下。</p><p>一个SAT求解器用于判断一个布尔表达式中的变量是否存在某个赋值能够使得该表达式取值为真。在这个表达式中，只能含有<strong>AND</strong>，<strong>OR</strong>，<strong>NOT</strong>，<strong>括号</strong>，以及<strong>布尔变量</strong>。如果可满足，大部分的 <em>SAT</em> 求解器（包括 MiniSAT）都会列出使该表达式为真的赋值。由于许多的问题都可以分解为一个大型的 SAT 问题（可能含有数千个变量），所以 <em>SAT</em> 求解器具有十分广泛的用途。</p><p>本文是一篇简单的 MiniSAT 用户指南。它描述了 MiniSAT 的使用方法，包括 它的输入格式、选项以及输出格式。</p><h2 id="合取范式-（Conjunctive-Normal-Form）"><a href="#合取范式-（Conjunctive-Normal-Form）" class="headerlink" title="合取范式 （Conjunctive Normal Form）"></a>合取范式 （<em>Conjunctive Normal Form</em>）</h2><p>如众多 <em>SAT</em> 求解器一样，<em>MiniSAT</em> 要求的输入为合取范式。合取范式由以下构造块构成：</p><ul><li><p>项（<em>term</em>）：一个项可以是一个布尔变量（比如：  x4），也可以是一个布尔变量的非（NOT x4，在这里可以写成 -x4）。</p></li><li><p>子句（<em>clause</em>）：一个字句是一个或多个项的集合，通过 OR 运算符（在这里记为 <code>|</code>）连接；在一个子句中，相同的变量不会重复出现。</p></li><li><p>表达式（<em>expression</em>）：一个表达式有一个或多个子句组成，通过 AND 运算符（在这里记为 <code>&amp;</code>）进行连接。</p></li></ul><p>一个 <em>CNF</em> 的示例：</p><pre><code>(x1 | x5 | x4) &amp;(-x1 | x5 | x3 | x4) &amp;(-x3 | x4).</code></pre><p>任何布尔表达式都能转化为 <em>CNF</em> ；完成该工作的算法和代码能在别的地方获得。（比如： 可以参考 <em>Russel</em> 和 <em>Norvig</em> 在1995 年撰写的 “ <em>Artificial Intelligence: A modern Approach</em> “）。</p><p><em>MiniSAT</em> 的输入格式</p><p>和大部分的 <em>SAT</em> 求解器一样， <em>MiniSAT</em> 所接受的输入是一种 <strong>DIMACS CNF</strong> 简化格式的文本。每一个以 <em>c</em> 字母开头的行都是注释。第一个非注释行必须是以下形式：</p><pre><code>p cnf NUMBER_OF_VARIABLES NUMBER_OF_CLAUSES</code></pre><p>后续的每一个非注释行定义一个子句。每一行都是一个以空格分隔的变量列表；一个正值就是对应的变量 (<strong>4 就是 x4</strong>)，而一个负值就是那个变量的非（<strong>-5 就是 -x5</strong>）。每一行必须以一个空格和数字<br><strong>0</strong> 结尾。</p><p>因此以上的 CNF 表达式可以写成：</p><pre><code>c Here is a comment.p cnf 5 3 1 -5 4 0 -1 5 3 4 0 -3 -4 0</code></pre><p>“ <em>p cnf</em> ” 这一行意思是这个 <em>CNF</em> 格式的 <em>SAT</em> 问题中，有 <code>5</code> 个变量以及 <code>3</code> 个子句。这一行之后的第一行就是第一个子句，也就是 <em>x1 | -x5 | x4</em>。</p><p>你可以把这看作是一个简单的表达式。或者你也可以把它看作为一个子句集合，而求解器的任务就是找到使所有子句为真的布尔变量赋值集合。</p><p>更多信息可以参考 <a href="http://www.satcompetition.org/2004/format-solvers2004.html" target="_blank" rel="noopener">SAT 2004 competition</a></p><h2 id="调用-MiniSAT"><a href="#调用-MiniSAT" class="headerlink" title="调用 MiniSAT"></a>调用 MiniSAT</h2><p>MiniSAT 的用法如下：</p><pre><code>minisat [options] [INPUT-FILE [RESULT-OUTPUT-FILE]]</code></pre><p><em>INPUT-FILE</em> 的格式为上述的 <em>DIMACS CNF</em> 格式，也可以是纯文本 或 <em>gizp</em> 压缩过的文件。你可以使用 <em>-h</em> 或者 <em>–help</em> 来查看其它的选项。</p><p>程序的选项包括：</p><pre><code>-pre = {none,once} [Turn on preprocessor]  -asymm  -rcheck  -grow = NUM [ must be greater than 0 ]  -polarity-mode = {true,false,rnd}  -decay = NUM [ 0 - 1 ]  -rnd-freq = NUM [ 0 - 1 ]  -dimacs = OUTPUT-FILE  -verbosity = {0,1,2}</code></pre><p>带值的选项必须在中间加上 <strong>=</strong>，然后再是它的值，比如：</p><pre><code>minisat -pre=once</code></pre><p>在许多问题中，使用预处理器是一个不错的想法（<em>-pre=once</em>）。</p><h2 id="MiniSAT-输出格式"><a href="#MiniSAT-输出格式" class="headerlink" title="MiniSAT 输出格式"></a><em>MiniSAT</em> 输出格式</h2><p>当运行的时候，<em>MiniSAT</em> 向标准错误流发送一些执行的不同统计信息。根据表达式是否可满足，它会向标准输出流输出 <em>SATISFIABLE</em> 或者 <em>UNSATIFIABLE</em> （不包括引号）。</p><p>如果你指定了一个 <em>RESULT-OUTPUT-FILE</em>（结果输出文件），<em>MiniSAT</em> 会往这个文件中写入文本。如果可满足，第一行就会是 <em>SAT</em>，如果不可满足，第一行就会是 <em>UNSAT</em> 。如果是 <em>SAT</em>，第二行就会是满足表达式的布尔变量赋值集合。（尽管还有其他的，它只产生一个赋值）。</p><p>因此对于以上的例子，它会在输出文件中生成：</p><pre><code>SAT1 2 -3 4 5 0</code></pre><p>这意味着它是可满足的，在 x1=t, x2=t, x3=f, x4=t, 以及 x5=t 情况下（其中 t 是 true，f 是 false）。回到我们最初的例子，我们可以看到这确实是一个解：</p><pre><code>(x1 | -x5 | x4) = t | -t | t = t  (-x1 | x5 | x3 | x4) = -t | t | f | t = t  (-x3 | x4) = -f | t = t</code></pre><h2 id="获得更多的解"><a href="#获得更多的解" class="headerlink" title="获得更多的解"></a>获得更多的解</h2><p>如果你想要获得另一个解，“<strong>明显</strong>”的方式是将前一个解取非，作为一个新的子句添加到表达式中。比如，在我们的示例中，我们可以用</p><pre><code>1 2 -3 4 5 0</code></pre><p>来产生一个新的输入（<strong>注意：子句的数量增加了！</strong>）：</p><pre><code>p cnf 5 4  1 -5 4 0  -1 5 3 4 0  -3 -4 0  -1 -2 3 -4 -5 0</code></pre><p>如果我们把这个放入文件 <em>second.in</em> 中，然后运行:</p><pre><code>minisat second.in second.out</code></pre><p>我们可以得到一个新的解，以下是 <em>second.out</em> 内容：</p><pre><code>SAT1 -2 -3 4 5 0</code></pre><p>即： x1=t, x2=f, x3=f, x4=t, 以及 x5=t。这是和前一个不一样的解，因为 <em>x2=f</em> 而不是 <em>x2=t</em>。我们可以验证一下（和上一次一样，因为 <em>x2</em> 不在任何一个子句中）：</p><pre><code>(x1 | -x5 | x4) = t | -t | t = t(-x1 | x5 | x3 | x4) = -t | t | f | t = t(-x3 | x4) = -f | t = t</code></pre><h2 id="译者补充：-MiniSAT-下载-与-编译"><a href="#译者补充：-MiniSAT-下载-与-编译" class="headerlink" title="译者补充： MiniSAT 下载 与 编译"></a>译者补充： <em>MiniSAT</em> 下载 与 编译</h2><p>以下操作均在 <em>Ubuntu</em> 终端环境下执行：</p><ol><li><p>下载 minisat 源代码</p><pre><code>wget http://minisat.se/downloads/minisat-2.2.0.tar.gz</code></pre></li><li><p>解压缩</p><pre><code>tar -xzf minisat-2.2.0.tar.gz</code></pre></li><li><p>阅读 REDME 文件，查看相关信息</p><pre><code>more README</code></pre></li></ol><p>内容如图：<br><img src="/img/2016-4-3-1.png" alt="README"></p><p>内容描述了 <em>minisat</em> 的构建过程以及使用示例。</p><ol><li><p>构建 <em>minisat</em></p><pre><code>export MROOT= ~/minisat  #设置系统环境变量cd core #由于只需要核心功能，转到 core 目录make rs    #使用 make 进行编译cp minisat_static ~/minisat/minisat #将生成的minisat_static 可执行文件复制到 `~/minisat` 目录下。</code></pre></li></ol><h2 id="译者补充：MiniSAT-使用"><a href="#译者补充：MiniSAT-使用" class="headerlink" title="译者补充：MiniSAT 使用"></a>译者补充：<em>MiniSAT</em> 使用</h2><p>以下操作在之前编译的基础之上：</p><ol><li><p>创建输入文件，内容如下：</p><p> <img src="/img/2016-4-3-2.png" alt="example/test1"></p></li><li><p>执行命令</p><p> <img src="/img/2016-4-3-3.png" alt="执行求解"></p></li><li><p>查看输出文件，内容如下：</p><p> <img src="/img/2016-4-3-4.png" alt="example/test1_r"></p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> MiniSAT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>武术之于我</title>
      <link href="/2016/03/16/%E6%AD%A6%E6%9C%AF%E4%B9%8B%E4%BA%8E%E6%88%91/"/>
      <url>/2016/03/16/%E6%AD%A6%E6%9C%AF%E4%B9%8B%E4%BA%8E%E6%88%91/</url>
      <content type="html"><![CDATA[<p><img src="/img/wushuzhiyuwo1.jpg" alt="摄于研究生实验室"></p><p>不算双节棍的练习，从大三开始到研一上我就没有练习过武术。<br>而实际上除了武术之外，其他所有的运动也都少了。</p><p>结果就是，差不多成了宅男，随之，脂肪开始染指肚皮，腹肌不再显现。对我而言，身形的变化并不是那么在意，而精神状态的变化才最让我开始紧张。</p><p>在经历过大四一年实习的折腾， 之后的日子，即使每天的工作只是在办公室玩玩电脑，看看书，也会深感疲惫，而加上晚上睡眠质量不高，次日就更加疲惫，于是，进入了恶性循环。身体素质每况愈下，而心理状态也未必能好到哪去，天天神思恍惚，有种混吃等死的感觉。所有的焦虑、紧张、负面思想随时涌上心头，再也无法压制或是转化，使得整个大脑的资源都被占用，变得疲于思考，丧失斗志。可以说，身体尚未彻底崩坏，而灵魂却快要被另一个人格取代。</p><p>这个学期，我觉得我再不做出改变，就完蛋了，这不是关乎自己未来前途，而是我本身这个人格的存亡。于是每天强制自己跳绳，俯卧撑以及腹肌训练，然后控制自己的睡眠时间，身体好像慢慢有力量充实了起来，不再腰酸背痛，晚上睡眠质量也很好，白天也不怎么会困。</p><p>而因为偶然，我发现了跆拳道社团的存在，经过简单了解，发现教练的来头不小，并且具有一定的权威，不只是简单的打打闹闹，因而便产生了加入训练的想法。而还未到跆拳道社团训练的时间，我收到了空手道社团的传单，一瞬间，脑子里想到了 腕力 和 豪力，那两只肌肉发达的宠物小精灵，觉得跆拳道练下半身，那么空手道就练上半身吧。 然后，在空手道课上，又知道了合气道，然后又进了合气道的圈。</p><p>现在…一周5天，每天两小时的训练，感觉还是很不错的。小朋友练一次酸一周，而我已经无所谓了。</p><p>练武术有一定年头，功夫上手没多少，但想法感悟还是有一些的。</p><h2 id="关于实战意义"><a href="#关于实战意义" class="headerlink" title="关于实战意义"></a>关于实战意义</h2><p>我个人觉得，不论是传统武术，空手道，合气道还是跆拳道，对于现在的普通人，实战意义并不大，即使每一个都有实战的说法在，其中有些套路动作，也确实有实战的意味，但真的动手打架，招式都是散的，局面是千变万化、出乎意料的，靠的是体力，爆发力，抗打击能力，速度以及反应速度。一般的社团训练肯定是不够的。要想能实战对抗，必须要不断去真打，去受伤，屡败屡战才能快速提高。而对于普通人，社会还算安定，完全没有打架的需要，而打架解决问题往往是最不聪明的，也不能真正去解决问题。所以，武术又有了防身术的说法，也就是说，既然不能用于主动打人，那我关键时候防身，以免吃亏。这是很多武术流派知时势，懂进退的地方，而传统武术，有些人还是沉溺于过往的幻想，把传统武术捧高，以此证明身为习练者的价值，好像有一种有极高个人战斗力的优越感。然而个人之勇，血气之勇，早被枪炮打的稀碎。人本身是弱小的，在物理存在上极为弱小的，压根没有“排山倒海”，“斗转星移”，“凌波微步”，“九阳神功”，“降龙十八掌”之类的东西，也没有一招一式练到纯熟，就真能提高多少战斗力。到头来，武功再高，也怕菜刀，牛皮吹破，徒增笑柄。</p><p><img src="/img/wushuzhiyuwo2.jpg" alt="摄于东华大学延安西路校区宿舍"></p><h2 id="我怎么看武术"><a href="#我怎么看武术" class="headerlink" title="我怎么看武术"></a>我怎么看武术</h2><p>经常有人问我，我是因为什么原因去学习武术。我自己看来，一方面，很小的时候看电视，就喜欢武侠，那种恩怨分明，快意恩仇的侠客，（最主要大概还是英雄救美吧，哦，“侠之大者，为国为民” 才是政治正确，笑 ：) ）这可能是大多数人曾有的幻想，另一方面，读书早，个头、力气难免弱于同学，受过欺负，也就想反抗。<br>好在我长的挺招人喜欢，心性还算单纯，少和人有冲突。所以，支撑我一直喜欢武术的，主要还是第一个原因。但是，我又说我破除了对武术的妄想，没有了实战的念头，那么现在，我为什么坚持学习这些东西？<br>武术的意义，并不在于招式本身可用于实战，套路、招式是提炼于生活、劳动和战争的，是一种意境的抽取，真的练得好，一招一式都很有味道，而身体是自然的融入，不是刻意的伸张，也就是所谓的“道法自然”，就像金庸小说《天龙八部》里的扫地僧，成龙所演《少林寺》的烧饭伙夫。武术本身应该是对一种对身体的操练，它能使身体变得灵活，使身材变得优美，而最关键的，便是其中的意境融于己身，这是 “天人合一” 的真趣。譬如说，太极拳中每一个动作，都会有一个名字，“鞭”，“捶”，“炮”，它都是一种象征，一种将身体化为他物的想象，而借着这种想象，才能从招式间流露出所谓的感觉，鞭的抽打，锤的厚重，炮的刚猛无匹，那“白鹤亮翅”，“饿虎扑食”，“巨蟒吐丹”，当你想象自己是那一种动物时候，你会发现，那些动作的特点，很容易就能展现出来，“提气上扬”，“前扑下按”，“腰身婉转”，而身与心合，心与意合的体验，着实是让人喜悦的。我其实并没有正经练过多少，一开始也是看拳谱自练，但我去学拳，师傅都说有点味道。因为我会思考，这一招，它的目的是什么，它取自什么，模仿了什么。而其中原理，便是发力用劲的关键。形意拳中讲五行，“劈崩钻炮横”，对应“金木水火土”，而实际脱胎于兵器的使用，将手化为“刀剑锤枪炮”，其中手法转换，身形变化，闪转腾挪，知其原本，就得其意味，就算没有实用价值，也乐在其中。</p><p>有人觉得武术没用，一是过高的幻想，世上没有一劳永逸的事，要是这样，那么同样学的人，到底谁弱谁强呢，总有其他的因素会有所影响，二是没有明白其中真正的价值，盲目追求套路的繁复，动作的高难度，或者所谓的标准，从而丧失其中的趣味。所以，真正的读书人才是学武的好胚子，以往师父教的不只是拳，更多是做人，所以对得起“师父”二字。乡村野人，不知事理，可能有一身蛮力，也无法练就武学中的高等境界，至少，也难得其中趣味。我此次学三门武道，在别人看来，我是为了耍酷，装逼，去撩妹，而实际上，我更多的是以观察者的角度，去体会这些东西，包括其中的文化，其中的教学方法，其中的规矩，服从是因为我的尊重，并不意味我绝对的赞同，不然我也不会三门都学。当然，习练之时，认识朋友，交流观点，强身健体，也是为了更好的利用花下去的时间。当然，如果我能坚持下去，并且不耽误其他的事情，我觉得，这对我自身的能力的信心也会有极大的增强。</p><p>写这篇文章，一是想写点东西，留点存在感，二是听到空手道上有学弟嘲讽武术队套路的无用。而据我所知，跆拳道社团，社长是一个学妹，她就是不服武术课老师嘲讽了空手道而创建了社团。门派偏见，除了让人看不见他人的好，夜郎自大，并没有什么真正的价值。而偏见，岂止是门派呢。</p><p><img src="/img/wushuzhiyuwo3.jpg" alt="摄于东华大学松江校区宿舍"></p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>摄影<br>卜祥兴 费凡 许赫</p>]]></content>
      
      <categories>
          
          <category> 感悟 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 感悟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见的程序分析优化技术</title>
      <link href="/2016/03/13/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
      <url>/2016/03/13/%E5%B8%B8%E8%A7%81%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
      <content type="html"><![CDATA[<h1 id="常见的程序分析优化技术"><a href="#常见的程序分析优化技术" class="headerlink" title="常见的程序分析优化技术"></a>常见的程序分析优化技术</h1><h2 id="常量折叠（Constant-Folding）"><a href="#常量折叠（Constant-Folding）" class="headerlink" title="常量折叠（Constant Folding）"></a>常量折叠（Constant Folding）</h2><p>在编译时识别代码中的常量表达式，并对之求值，而不是留在运行时再进行求值。<br>例如    </p><pre><code>i = 320 * 200 * 32;</code></pre><p>现代编译器不会真的为这条语句生成两个乘法指令以及一个存储指令，而是在编译时进行求值（2,048,000），然后用这个值直接进行替换。<br>而在</p><pre><code>0*x</code></pre><p>语句中，即使编译器不知道 <code>x</code> 变量的值，它也能用 0 对表达式进行替换</p><p>而常量折叠也不仅仅能够在数值计算中使用，也能在字符串连接运算中使用。</p><pre><code>&quot;abc&quot;+ &quot;def&quot;</code></pre><p>会被替换为</p><pre><code>&quot;abcdef&quot;</code></pre><p>常量折叠可以在编译器前端高级语言的中间表示树期间，也就是在翻译成三地址指令之前完成，或者在编译器后端作为常量传播的辅助。</p><blockquote><p>注意: 存在交叉编译的情况，这时候需要考虑在不同的架构中，浮点数的精度存在差异，盲目进行常量折叠可能导致宿主机于目标主机的算术计算不一致的情况。</p></blockquote><h2 id="常量传播（Constant-Propagation）"><a href="#常量传播（Constant-Propagation）" class="headerlink" title="常量传播（Constant Propagation）"></a>常量传播（Constant Propagation）</h2><p>常量传递是在编译期间用常量的值替换代码表达式中常量的过程。</p><pre><code>int x =14;int y = 7 - x / 2;return y * (28 / x + 2);</code></pre><p>传递 x 后：</p><pre><code>int x = 14;int y = 7 - 14 / 2;return y * (28/x + 2);</code></pre><p>继续传递 y 后：</p><pre><code>int x = 14;int y  = 0;return 0;</code></pre><p>（未完待续）</p>]]></content>
      
      <categories>
          
          <category> 程序分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>反直觉的“三门问题”</title>
      <link href="/2015/10/24/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2015/10/24/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%89%E9%97%A8%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="“三门问题”是什么"><a href="#“三门问题”是什么" class="headerlink" title="“三门问题”是什么"></a>“三门问题”是什么</h2><p>三门问题，又称为“蒙提霍尔问题”、“蒙提霍尔悖论”。</p><p>这个问题出自一个美国电视节目Let’s make a deal。而其名字则来自于节目主持人蒙提霍尔(Monty Hall problem)的名字。</p><p>在电视节目中，参与者的面前有三扇门，其中一扇门背后是汽车，另外两扇门背后是山羊。</p><p>参与者只能选择打开其中一扇门，如果门背后的是汽车，那么参与者就可以得到它，如果是羊，那么什么都不会得到。</p><p>然而，在参与者做出选择后，主持人已知三扇门后藏了什么的情况下，打开另外两扇门中的其中一扇，背后的是一只羊。</p><p>随后，主持人问参赛者，要不要改变选择，去选另一扇门。</p><h2 id="问题关键"><a href="#问题关键" class="headerlink" title="问题关键"></a>问题关键</h2><p><strong>那么问题就是：有没有必要去更改选择？选择另一扇门是否更有利？</strong></p><h2 id="错误的直觉"><a href="#错误的直觉" class="headerlink" title="错误的直觉"></a>错误的直觉</h2><p>有的人可能会想：换不换选择，选中的可能性都为<code>三分之一</code>，意义不大。</p><p>还有的人认为：在主持人剔除一个选择后，更换选择后，抽中的概率从<code>三分之一</code>上升为 <code>二分之一</code>。<em>这种思维很诡异，如果说概率提高了，那应该是两个剩余的选项都提高，那么其实剩余两扇门抽中汽车的概率应该是相等的，换不换依旧是没有意义的。</em></p><h2 id="那么到底改不改换"><a href="#那么到底改不改换" class="headerlink" title="那么到底改不改换"></a>那么到底改不改换</h2><p>神秘主义的人可能会这么想</p><blockquote><p>反正换不换都一样，不如换着试试，指不定真中了呢。</p></blockquote><p>阴谋论的人大概会这么想</p><blockquote><p>不对！你这么说，肯定想唬我，不想让我得到那辆车…坚决不换！</p></blockquote><p>天秤座则陷入痛苦不堪的选择的简谐振动之中</p><blockquote><p>换？不换？换？不换…啊啊啊，到底选哪个好，好纠结。</p></blockquote><h3 id="“政治”正确的做法"><a href="#“政治”正确的做法" class="headerlink" title="“政治”正确的做法"></a>“政治”正确的做法</h3><p>当然是换，我们不能以小人之心度君子之腹，主持人这么做，必有深意。换一换，得之我命，失之也就一句“我X”的事。赌一把吧。</p><p>好吧，严肃点，不开玩笑了。我们做一个选择，必须还是要理性，虽然随机的貌似更有趣，但面对人生大事的时候可不能马虎啊。</p><h4 id="解法一（枚举法）："><a href="#解法一（枚举法）：" class="headerlink" title="解法一（枚举法）："></a>解法一（枚举法）：</h4><pre><code>1. 假如汽车在第一次选择的门背后，那么第二次    a. 选择不换，那么必能得到汽车，中奖概率为 1    b. 选择换，那么必不能得到汽车，中奖概率为 02. 假如汽车不在第一次选择的门背后，那么第二次    a. 选择不换，那么必不能得到汽车，中奖概率为 0    b. 选择换，那么必能得到汽车，中奖概率为 1综合计算下，第二次变更选择的情况下，中奖概率是多少：    第一种情况下概率：        1/3 * 0 = 0    第二种情况下概率：        2/3 * 1 = 2/3    综合概率：        0 + 2/3 = 2/3</code></pre><p>显然，不换的情况下，我们中奖的概率在第一次就决定了，为 <code>三分之一</code>，而如果修改选择，我们中奖的概率则提升到了 <code>三分之二</code> ，当然选择换。</p><blockquote><p>⊙▂⊙，枚举法是不是太蠢了点。如果给一百扇门让我选，我当时就要吓懵比了。当然，其实并不会。那么有没有更直观的方法呢。</p></blockquote><h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><pre><code>我们可以知道，三扇门每扇门背后是汽车的概率都是 三分之一 。那么在我们选出一扇门后，这扇门的中奖概率为 三分之一 ，另外两扇门的中奖概率之和就是 三分之二 。 在主持人帮我们剔除其中一个错误选择后， 则相当于：    原来 三分之二 的概率 被剩下的一扇门 “继承” 了。聪明的我们当然应该 改选 这扇更有 “前途” 的门。“ WHAT？!发生了什么。什么叫继承了概率？什么鬼？！ ”其实可以这么理解：     我们第一次选择时，如果选择另外的两扇门的组合，则获奖概率是 三分之二，然而规则是不允许我们选两扇门的。    正当我们纠结的时候，善解人意的主持人很配合地为我们剔除了其中一个不会中奖的选项，那么我们就能选那个 “组合” 了，(哦，卖狗的，天上掉馅饼了！ 那两个门突然合并成了一个门了！)，那么剩下的那扇门代表的是依然是 三分之二 的中奖概率。</code></pre><h3 id="继承到底是怎么回事？"><a href="#继承到底是怎么回事？" class="headerlink" title="继承到底是怎么回事？"></a>继承到底是怎么回事？</h3><p>如果原来是 <code>n</code> 扇门的话，那么，第一次选择的门中奖概率为 <code>1 / n</code> , 而剩下门中奖概率之和则为 <code>(n-1) / n</code>。</p><p>主持人帮我们消除其中一扇门之后，中奖概率应该怎么继承？当然应该由剩下的 <code>n-2</code> 门均分，那么剩下的每扇门的中奖概率变成了 <code>((n-1) / n) / (n-2)</code> 。</p><p>那么，剩余的 <code>n-2</code> 扇门的中奖概率提升为原来的 <code>(n-1) / (n-2)</code>倍了，即 <code>1 + 1 / (n-2)</code>。</p><p>这么看来，三扇门的问题只是其中一个具体问题。将 <code>n=3</code> 代入，则剩下的 一<code>(3-2)</code> 扇门的概率上升为原来的 两倍<code>(1 + 1 / (3-2))</code>倍了，这个时候，谁不换谁傻。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题关键在于，主持人是知道门背后藏有什么的。</p><p>我们可以理解为，当一个随机系统引入了一个不随机的因素，整个系统就不能单纯当作随机系统来看了。</p><p>所以换不换，是要仔细思考的问题。2B or not 2B , that’s a question !</p><p>嗯，做人要有理想，但还需要根据现实情况来改变自己的理想，不能一味地盲目坚持。</p>]]></content>
      
      <categories>
          
          <category> 概率统计 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>中国计算机学会推荐国际学术刊物（计算机科学理论）</title>
      <link href="/2015/09/11/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E5%88%8A%E7%89%A9%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%90%86%E8%AE%BA%EF%BC%89/"/>
      <url>/2015/09/11/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E5%88%8A%E7%89%A9%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E7%90%86%E8%AE%BA%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="A类"><a href="#A类" class="headerlink" title="A类"></a>A类</h2><table><thead><tr><th>序号</th><th>刊物简称</th><th>刊物全称</th><th>出版社</th><th>网址</th></tr></thead><tbody><tr><td>1</td><td>IANDC</td><td>Information and Computation</td><td>Elsevier</td><td><a href="http://www.journals.elsevier.com/information-and-computation/" target="_blank" rel="noopener">http://www.journals.elsevier.com/information-and-computation/</a></td></tr><tr><td>2</td><td>SICOMP</td><td>SIAM Journal on Computing</td><td>SIAM</td><td><a href="http://epubs.siam.org/journal/smjcat" target="_blank" rel="noopener">http://epubs.siam.org/journal/smjcat</a></td></tr></tbody></table><h2 id="B类"><a href="#B类" class="headerlink" title="B类"></a>B类</h2><table><thead><tr><th>序号</th><th>刊物简称</th><th>刊物全称</th><th>出版社</th><th>网址</th></tr></thead><tbody><tr><td>1</td><td>TALG</td><td>ACM Transactions on Algorithms</td><td>ACM</td><td><a href="http://talg.acm.org/" target="_blank" rel="noopener">http://talg.acm.org/</a></td></tr><tr><td>2</td><td>TOCL</td><td>ACM Transactions on Computational Logic</td><td>ACM</td><td><a href="http://tocl.acm.org/" target="_blank" rel="noopener">http://tocl.acm.org/</a></td></tr><tr><td>3</td><td>TOMS</td><td>ACM Transactions on Mathematical Software</td><td>ACM</td><td><a href="http://toms.acm.org/" target="_blank" rel="noopener">http://toms.acm.org/</a></td></tr><tr><td>4</td><td></td><td>Algorithmica</td><td>Springer</td><td><a href="http://www.springerlink.com/content/100117/" target="_blank" rel="noopener">http://www.springerlink.com/content/100117/</a></td></tr><tr><td>5</td><td></td><td>Computational complexity</td><td>Springer</td><td><a href="http://www.springer.com/birkhauser/computer+science/journa" target="_blank" rel="noopener">http://www.springer.com/birkhauser/computer+science/journa</a></td></tr><tr><td>7</td><td></td><td>Formal Methods in System Design</td><td>Springer</td><td><a href="http://www.springerlink.com/content/1572-8102/" target="_blank" rel="noopener">http://www.springerlink.com/content/1572-8102/</a></td></tr><tr><td>8</td><td></td><td>INFORMS Journal on Computing</td><td>INFORMS</td><td><a href="http://www.informs.org/Pubs/IJOC" target="_blank" rel="noopener">http://www.informs.org/Pubs/IJOC</a></td></tr><tr><td>9</td><td>JCSS</td><td>Journal of Computer and System Sciences</td><td>Elsevier</td><td><a href="http://www.journals.elsevier.com/journal-of-computer-and-system-sciences/" target="_blank" rel="noopener">http://www.journals.elsevier.com/journal-of-computer-and-system-sciences/</a></td></tr><tr><td>10</td><td>JGO</td><td>Journal of Global Optimization</td><td>Springer</td><td><a href="http://link.springer.com/journal/10898" target="_blank" rel="noopener">http://link.springer.com/journal/10898</a></td></tr><tr><td>11</td><td></td><td>Journal of Symbolic Computation</td><td>Elsevier</td><td><a href="http://www.elsevier.com/wps/find/journaldescription.cws_home/622902/description" target="_blank" rel="noopener">http://www.elsevier.com/wps/find/journaldescription.cws_home/622902/description</a></td></tr><tr><td>12</td><td>MSCS</td><td>Mathematical Structures in Computer Science</td><td>Cambridge University Press</td><td><a href="http://journals.cambridge.org/action/displayJournal?jid=MSC" target="_blank" rel="noopener">http://journals.cambridge.org/action/displayJournal?jid=MSC</a></td></tr><tr><td>13</td><td>TCS</td><td>Theoretical Computer Science</td><td>Elsevier</td><td><a href="http://www.journals.elsevier.com/theoretical-computer-science/" target="_blank" rel="noopener">http://www.journals.elsevier.com/theoretical-computer-science/</a></td></tr></tbody></table><h2 id="C类"><a href="#C类" class="headerlink" title="C类"></a>C类</h2><table><thead><tr><th>序号</th><th>刊物简称</th><th>刊物全称</th><th>出版社</th><th>网址</th></tr></thead><tbody><tr><td>1</td><td></td><td>Annals of Pure and Applied Logic</td><td>Elsevierc</td><td><a href="http://www.sciencedirect.com/science/journal/01680072" target="_blank" rel="noopener">http://www.sciencedirect.com/science/journal/01680072</a></td></tr><tr><td>2</td><td></td><td>Acta Informatica</td><td>Springer</td><td><a href="http://www.springerlink.com/content/100460/" target="_blank" rel="noopener">http://www.springerlink.com/content/100460/</a></td></tr><tr><td>3</td><td></td><td>Discrete Applied Mathematics</td><td>Elsevier</td><td><a href="http://www.elsevier.com/wps/find/journaldescription.cws_home/505609/description" target="_blank" rel="noopener">http://www.elsevier.com/wps/find/journaldescription.cws_home/505609/description</a></td></tr><tr><td>4</td><td></td><td>Fundamenta Informaticae</td><td>IOS Press</td><td><a href="http://fi.mimuw.edu.pl/index.php/FI/index" target="_blank" rel="noopener">http://fi.mimuw.edu.pl/index.php/FI/index</a></td></tr><tr><td>5</td><td></td><td>Higher-Order and Symbolic Computation</td><td>Springer</td><td><a href="http://springerlink.metapress.com/content/1573-0557/" target="_blank" rel="noopener">http://springerlink.metapress.com/content/1573-0557/</a></td></tr><tr><td>6</td><td></td><td>Information Processing Letters</td><td>Elsevier</td><td><a href="http://www.journals.elsevier.com/information-processing-letters/#" target="_blank" rel="noopener">http://www.journals.elsevier.com/information-processing-letters/#</a></td></tr><tr><td>7</td><td>JCOMPLEXITY</td><td>Journal of Complexity</td><td>Elsevier</td><td><a href="http://www.journals.elsevier.com/journal-of-complexity/" target="_blank" rel="noopener">http://www.journals.elsevier.com/journal-of-complexity/</a></td></tr><tr><td>8</td><td>LOGCOM</td><td>Journal of Logic and Computation</td><td>Oxford University Press</td><td><a href="http://logcom.oxfordjournals.org/" target="_blank" rel="noopener">http://logcom.oxfordjournals.org/</a></td></tr><tr><td>9</td><td></td><td>Journal of Symbolic Logic</td><td>Association for Symbolic Logic</td><td><a href="http://www.aslonline.org/journals-journal.html" target="_blank" rel="noopener">http://www.aslonline.org/journals-journal.html</a></td></tr><tr><td>10</td><td>LMCS</td><td>Logical Methods in Computer Science</td><td>LMCS</td><td><a href="http://www.lmcs-online.org/index.php" target="_blank" rel="noopener">http://www.lmcs-online.org/index.php</a></td></tr><tr><td>11</td><td>SIDMA</td><td>SIAM Journal on Discrete Mathematics</td><td>SIAM</td><td><a href="http://www.siam.org/journals/sidma.php" target="_blank" rel="noopener">http://www.siam.org/journals/sidma.php</a></td></tr><tr><td>12</td><td></td><td>Theory of Computing Systems</td><td>Springer</td><td><a href="http://www.springerlink.com/content/1433-0490/" target="_blank" rel="noopener">http://www.springerlink.com/content/1433-0490/</a></td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> 计算机科学理论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学术论文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql常用命令</title>
      <link href="/2015/08/07/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2015/08/07/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="一、连接Mysql"><a href="#一、连接Mysql" class="headerlink" title="一、连接Mysql"></a>一、连接Mysql</h2><p><strong>格式:</strong></p><pre><code>mysql -h主机地址 -u用户名 －p用户密码</code></pre><blockquote><p>用户名前可以有空格也可以没有空格，但是密码前必须没有空格，否则让你重新输入密码</p></blockquote><ol><li><p>连接本机上的mysql</p><p> 键入命令</p><pre><code>mysql -u root -p</code></pre><p> 回车后提示你输密码</p></li><li><p>连接到远程主机上的MYSQL</p><p> 假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令：</p><pre><code>mysql -h110.110.110.110 -u root -pabcd123</code></pre></li></ol><h2 id="二、修改密码"><a href="#二、修改密码" class="headerlink" title="二、修改密码"></a>二、修改密码</h2><p><strong>格式</strong></p><pre><code>mysqladmin -u用户名 -p旧密码 password 新密码</code></pre><ol><li><p>给root加个密码ab12</p><p> mysqladmin -u root -password ab12</p><blockquote><p>因为开始时root没有密码，所以-p旧密码一项就可以省略了。</p></blockquote></li><li><p>再将root的密码改为djg345</p><pre><code>mysqladmin -u root -p ab12 password djg345</code></pre></li></ol><h2 id="三、增加新用户"><a href="#三、增加新用户" class="headerlink" title="三、增加新用户"></a>三、增加新用户</h2><p><strong>格式</strong></p><pre><code>grant select on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;</code></pre><ol><li><p>增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用root用户连入MYSQL，然后键入以下命令：</p><pre><code>grant select,insert,update,delete on *.* to test1@&quot;%&quot; Identified by &quot;abc&quot;;</code></pre></li><li><p>增加一个用户test2密码为abc,让他只可以在localhost上登录，并可以对数据库mydb进行查询、插入、修改、删除的操作（localhost指本地主机，即MYSQL数据库所在的那台主机）</p><pre><code>grant select,insert,update,delete on mydb.* to test2@localhost identified by &quot;abc&quot;;</code></pre></li><li><p>如果你不想test2有密码，可以再打一个命令将密码消掉。</p><pre><code>grant select,insert,update,delete on mydb.* to test2@localhost identified by &quot;&quot;;</code></pre></li></ol><h2 id="四、相关信息查看"><a href="#四、相关信息查看" class="headerlink" title="四、相关信息查看"></a>四、相关信息查看</h2><h3 id="显示当前数据库服务器中的数据库列表"><a href="#显示当前数据库服务器中的数据库列表" class="headerlink" title="显示当前数据库服务器中的数据库列表"></a>显示当前数据库服务器中的数据库列表</h3><pre><code>mysql&gt; SHOW DATABASES;</code></pre><blockquote><p>注意：mysql库里面有MYSQL的系统信息，我们改密码和新增用户，实际上就是用这个库进行操作。</p></blockquote><h3 id="显示数据库中的数据表"><a href="#显示数据库中的数据表" class="headerlink" title="显示数据库中的数据表"></a>显示数据库中的数据表</h3><pre><code>mysql&gt; USE 库名；mysql&gt; SHOW TABLES;</code></pre><h3 id="显示数据表的结构"><a href="#显示数据表的结构" class="headerlink" title="显示数据表的结构"></a>显示数据表的结构</h3><pre><code>mysql&gt; DESCRIBE 表名;</code></pre><h3 id="显示use的数据库名"><a href="#显示use的数据库名" class="headerlink" title="显示use的数据库名"></a>显示use的数据库名</h3><pre><code>mysql&gt; SELECT DATABASE();</code></pre><h3 id="显示当前的user"><a href="#显示当前的user" class="headerlink" title="显示当前的user"></a>显示当前的user</h3><pre><code>mysql&gt; SELECT USER();</code></pre><h2 id="五、数据库操作"><a href="#五、数据库操作" class="headerlink" title="五、数据库操作"></a>五、数据库操作</h2><h3 id="建立数据库"><a href="#建立数据库" class="headerlink" title="建立数据库"></a>建立数据库</h3><pre><code>mysql&gt; CREATE DATABASE 库名;</code></pre><h3 id="建立数据表"><a href="#建立数据表" class="headerlink" title="建立数据表"></a>建立数据表</h3><pre><code>mysql&gt; USE 库名;mysql&gt; CREATE TABLE 表名 (字段名 VARCHAR(20), 字段名 CHAR(1));</code></pre><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><pre><code>mysql&gt; DROP DATABASE 库名;</code></pre><h3 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h3><pre><code>mysql&gt; DROP TABLE 表名；</code></pre><h3 id="将表中记录清空"><a href="#将表中记录清空" class="headerlink" title="将表中记录清空"></a>将表中记录清空</h3><pre><code>mysql&gt; DELETE FROM 表名;</code></pre><h3 id="显示表中的记录"><a href="#显示表中的记录" class="headerlink" title="显示表中的记录"></a>显示表中的记录</h3><pre><code>mysql&gt; SELECT * FROM 表名;</code></pre><h3 id="往表中插入记录"><a href="#往表中插入记录" class="headerlink" title="往表中插入记录"></a>往表中插入记录</h3><pre><code>mysql&gt; INSERT INTO 表名 VALUES (&quot;hyq&quot;,&quot;M&quot;);</code></pre><h3 id="更新表中数据"><a href="#更新表中数据" class="headerlink" title="更新表中数据"></a>更新表中数据</h3><pre><code>mysql-&gt; UPDATE 表名 SET 字段名1=&apos;a&apos;,字段名2=&apos;b&apos; WHERE 字段名3=&apos;c&apos;;</code></pre><h3 id="用文本方式将数据装入数据表中"><a href="#用文本方式将数据装入数据表中" class="headerlink" title="用文本方式将数据装入数据表中"></a>用文本方式将数据装入数据表中</h3><pre><code>mysql&gt; LOAD DATA LOCAL INFILE &quot;D:/mysql.txt&quot; INTO TABLE 表名;</code></pre><h3 id="导入-sql文件命令"><a href="#导入-sql文件命令" class="headerlink" title="导入.sql文件命令"></a>导入.sql文件命令</h3><pre><code>mysql&gt; USE 数据库名;mysql&gt; SOURCE d:/mysql.sql;</code></pre><h3 id="命令行修改root密码"><a href="#命令行修改root密码" class="headerlink" title="命令行修改root密码"></a>命令行修改root密码</h3><pre><code>mysql&gt; UPDATE mysql.user SET password=PASSWORD(&apos;新密码&apos;) WHERE User=&apos;root&apos;;mysql&gt; FLUSH PRIVILEGES;</code></pre><h2 id="六、一个建库和建表以及插入数据的实例"><a href="#六、一个建库和建表以及插入数据的实例" class="headerlink" title="六、一个建库和建表以及插入数据的实例"></a>六、一个建库和建表以及插入数据的实例</h2><pre><code>drop database if exists school; //如果存在SCHOOL则删除create database school; //建立库SCHOOLuse school; //打开库SCHOOLcreate table teacher //建立表TEACHER(id int(3) auto_increment not null primary key,name char(10) not null,address varchar(50) default &apos;深圳&apos;,year date); //建表结束//以下为插入字段insert into teacher values(&apos;&apos;,&apos;allen&apos;,&apos;大连一中&apos;,&apos;1976-10-10&apos;);insert into teacher values(&apos;&apos;,&apos;jack&apos;,&apos;大连二中&apos;,&apos;1975-12-23&apos;);</code></pre><p>如果你在mysql提示符键入上面的命令也可以，但不方便调试。</p><ol><li><p>你可以将以上命令原样写入一个文本文件中，假设为school.sql，然后复制到c:\下，并在DOS状态进入目录\mysql\bin，然后键入以下命令：</p><pre><code>mysql -uroot -p密码 &lt; c:\\school.sql</code></pre><p> 如果成功，空出一行无任何显示；如有错误，会有提示。（以上命令已经调试，你只要将//的注释去掉即可使用）。</p></li><li><p>或者进入命令行后使用 </p><pre><code>mysql&gt; source c:\\school.sql; </code></pre><p> 也可以将school.sql文件导入数据库中。</p></li></ol><h3 id="将文本数据转到数据库中"><a href="#将文本数据转到数据库中" class="headerlink" title="将文本数据转到数据库中"></a>将文本数据转到数据库中</h3><ol><li><p>文本数据应符合的格式：字段数据之间用tab键隔开，null值用\n来代替.例：</p><pre><code>3 rose 大连二中 1976-10-104 mike 大连一中 1975-12-23</code></pre><p> 假设你把这两组数据存为school.txt文件，放在c盘根目录下。</p></li><li><p>数据传入命令 </p><pre><code>load data local infile &quot;c:\\school.txt&quot; into table 表名;</code></pre><blockquote><p>注意：你最好将文件复制到\mysql\bin目录下，并且要先用use命令打表所在的库。</p></blockquote></li></ol><h2 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h2><h3 id="导出整个数据库"><a href="#导出整个数据库" class="headerlink" title="导出整个数据库"></a>导出整个数据库</h3><p>导出文件默认是存在mysql\bin目录下</p><pre><code>mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名mysqldump -u user_name -p123456 database_name &gt; outfile_name.sql</code></pre><h3 id="导出一个表"><a href="#导出一个表" class="headerlink" title="导出一个表"></a>导出一个表</h3><pre><code>mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql</code></pre><h3 id="导出一个数据库结构"><a href="#导出一个数据库结构" class="headerlink" title="导出一个数据库结构"></a>导出一个数据库结构</h3><pre><code>mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql</code></pre><blockquote><p>-d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table</p></blockquote><h3 id="带语言参数导出"><a href="#带语言参数导出" class="headerlink" title="带语言参数导出"></a>带语言参数导出</h3><pre><code>mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql</code></pre><h3 id="备份数据库-1"><a href="#备份数据库-1" class="headerlink" title="备份数据库"></a>备份数据库</h3><pre><code>mysqldump -uroot -p test_db &gt; test_db.sql</code></pre><h3 id="恢复数据库"><a href="#恢复数据库" class="headerlink" title="恢复数据库"></a>恢复数据库</h3><pre><code>mysql -uroot -p test_db &lt; test_db.sql </code></pre><h3 id="创建权限"><a href="#创建权限" class="headerlink" title="创建权限"></a>创建权限</h3><pre><code>grant all privileges on test_db.* to test_db@&apos;localhost&apos; identified by &apos;123456&apos;; </code></pre><p>兼容mysql4.1之前模式： </p><pre><code>update mysql.user set password=old_password(&apos;123456&apos;) where user=&apos;test_db&apos;; </code></pre><h3 id="忘记密码"><a href="#忘记密码" class="headerlink" title="忘记密码"></a>忘记密码</h3><p>在 “<strong>my.cnf</strong>“ 或 “<strong>my.ini</strong>“ 文件的 “<strong>mysqld</strong>“ 配置段添加 “<strong>skip-grant-tables</strong>“ ，然后重新启动 <strong>mysql</strong> 即可登录修改 <strong>root</strong> 密码。</p>]]></content>
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python计时工具:timeit</title>
      <link href="/2015/08/05/python%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7/"/>
      <url>/2015/08/05/python%E8%AE%A1%E6%97%B6%E5%B7%A5%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>有时候，我们写了一个小程序，自我感觉良好。通常这个时候就会想要测试一下运行的效率。最基本的，就是测量程序的运行时间。</p><h2 id="常规方法"><a href="#常规方法" class="headerlink" title="常规方法"></a>常规方法</h2><p>通常我们会这么做：</p><ol><li>将程序代码封装在一个函数中，然后再主函数中调用它</li><li>在函数调用前打一个时间戳 t1</li><li>在函数调用后打一个时间戳 t2</li><li>最后，计算两个时间戳的差值 t2 - t1</li><li>输出时间差</li></ol><h3 id="利用time模块（不推荐）。"><a href="#利用time模块（不推荐）。" class="headerlink" title="利用time模块（不推荐）。"></a>利用time模块（不推荐）。</h3><h4 id="time-localtime-time-time-time-clock-对比："><a href="#time-localtime-time-time-time-clock-对比：" class="headerlink" title="time.localtime(),  time.time(),  time.clock() 对比："></a>time.localtime(),  time.time(),  time.clock() 对比：</h4><ul><li><p>time.localtime()，localtime返回的是struct_time，包含年月日，显然没有必要，更重要的是localtime()的精度依赖于time()</p></li><li><p>time.time()，time返回的是UTC时间（seconds since the 00:00:00 UTC on January 1）。在很多系统，包括windows下精度很差，win32下的精度只有1/18.2秒。不过在Unix/Linux系统下，time()的精度还是很高的。</p></li><li><p>Python的标准库手册推荐在任何系统下都尽量使用time.clock()。不过要注意是在win32系统下，这个函数返回的是真实时间（wall time），而在Unix/Linux下返回的是CPU时间。在win32下，这个函数的时间分辨率好于1微秒。</p></li></ul><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code># -*- coding: utf-8 -*-#!/bin/env pythondef test():    L=[]    for i in range(100):        L.append(i)if __name__==&apos;__main__&apos;:    from time import clock    start=clock()    for i in range(10000):        test()    finish=clock()    print (finish-start)/10000</code></pre><h4 id="执行结果为"><a href="#执行结果为" class="headerlink" title="执行结果为"></a>执行结果为</h4><pre><code>0.00032365431221</code></pre><p>这样倒是没什么问题，但有时候就比较麻烦，比如想要测试多次，就需要再套一层循环。</p><p>而在 <code>python</code> 中，提供了一个名为 <code>timeit</code> 的计时工具。</p><h2 id="timeit模块"><a href="#timeit模块" class="headerlink" title="timeit模块"></a>timeit模块</h2><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p><code>timeit</code> 模块定义了一个 <code>Timer类</code>。该类接收两个参数。</p><ul><li>第一个参数，是你要计时的语句和函数；</li><li>第二个参数，是为第一个参数语句构建环境的导入语句</li></ul><p>创建 <code>Timer</code> 类后，即可调用 <code>timeit</code> 方法进行计时。</p><ul><li>接受一个参数作为被计时语句的调用次数，默认为一百万次</li><li>返回所耗费的秒数</li></ul><p>另一个可以调用的方法为 <code>repeat</code> 。</p><ul><li>接收两个参数。第一个参数为整个测试试验的次数，第二个参数为测试的次数。</li><li>返回每次试验的结果</li></ul><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><pre><code># -*- coding: utf-8 -*-#!/bin/env pythondef test1():    n=0    for i in range(101):        n+=i    return ndef test2():    return sum(range(101))def test3():    return sum(x for x in range(101))if __name__==&apos;__main__&apos;:    from timeit import Timer    t1=Timer(&quot;test1()&quot;,&quot;from __main__ import test1&quot;)    t2=Timer(&quot;test2()&quot;,&quot;from __main__ import test2&quot;)    t3=Timer(&quot;test3()&quot;,&quot;from __main__ import test3&quot;)    print t1.timeit(10000)    print t2.timeit(10000)    print t3.timeit(10000)    print t1.repeat(3,10000)    print t2.repeat(3,10000)    print t3.repeat(3,10000)</code></pre><h4 id="结果如下"><a href="#结果如下" class="headerlink" title="结果如下"></a>结果如下</h4><pre><code>3.218314897560.1090828582964.83077821343[3.2328774327463403, 3.200496361967792, 3.219513164382626][0.11024445844373787, 0.10911708052280389, 0.10891761383080834][4.817947811802895, 4.892466221265554, 5.003930946530911]</code></pre>]]></content>
      
      <categories>
          
          <category> 技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一小时掌握sqlite</title>
      <link href="/2015/08/03/%E4%B8%80%E5%B0%8F%E6%97%B6%E6%8E%8C%E6%8F%A1sqlite/"/>
      <url>/2015/08/03/%E4%B8%80%E5%B0%8F%E6%97%B6%E6%8E%8C%E6%8F%A1sqlite/</url>
      <content type="html"><![CDATA[<h2 id="sqlite是什么"><a href="#sqlite是什么" class="headerlink" title="sqlite是什么"></a>sqlite是什么</h2><p>SQLite 是一个开源的<strong>嵌入式</strong>关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是<strong>高度便携、使用方便、结构紧凑、高效、可靠</strong>。 </p><p>与其他数据库管理系统不同，SQLite 的安装和运行非常简单，在大多数情况下 - 只要确保SQLite的二进制文件存在即可开始创建、连接和使用数据库。<strong>即不用额外安装数据库软件即可使用数据。</strong></p><p>如果您正在寻找一个嵌入式数据库项目或解决方案，SQLite是绝对值得考虑。</p><h2 id="sqlite安装"><a href="#sqlite安装" class="headerlink" title="sqlite安装"></a>sqlite安装</h2><h3 id="windows-环境"><a href="#windows-环境" class="headerlink" title="windows 环境"></a>windows 环境</h3><ol><li><p>进入<a href="http://www.sqlite.org/download.html" target="_blank" rel="noopener">下载页面</a> ，下载windows预编译 (Precompiled Binaries for Windows) 的二进制文件包。</p><pre><code>sqlite-shell-win32-x86-&lt;build#&gt;.zipsqlite-dll-win32-x86-&lt;build#&gt;.zip</code></pre><blockquote><p>注意: &lt;build#&gt; 是 sqlite 的编译版本号</p></blockquote></li><li><p>将 zip 文件解压到你的磁盘，并将解压后的目录添加到系统的 PATH 变量中，以方便在命令行中执行 sqlite 命令。</p></li><li><p>可选: 如果你计划发布基于 sqlite 数据库的应用程序，你还需要下载源码 (Source Code) 以便编译和利用其 API</p><pre><code>sqlite-amalgamation-&lt;build#&gt;.zip</code></pre></li></ol><h3 id="Linux-环境"><a href="#Linux-环境" class="headerlink" title="Linux 环境"></a>Linux 环境</h3><ol><li><p>Debian 或 Ubuntu环境下</p><pre><code>/* For Debian or Ubuntu /*  $ sudo apt-get install sqlite3 sqlite3-dev</code></pre></li><li><p>RedHat, CentOS, or Fedora</p><pre><code>/* For RedHat, CentOS, or Fedora/*  $ yum install SQLite3 sqlite3-dev </code></pre></li></ol><h3 id="Mac-OX-环境"><a href="#Mac-OX-环境" class="headerlink" title="Mac OX 环境"></a>Mac OX 环境</h3><p><strong>雪豹或者更新版本系统中已经自带</strong></p><h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><pre><code>sqlite3 test.db</code></pre><p><img src="/img/2015-8-3-1.png" alt="创建数据库"></p><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><pre><code>sqlite&gt; create table user (id integer primary key, name text, age integer);</code></pre><ul><li>表名<strong>user</strong></li><li>三个字段 id, name, age</li><li>id 为 主键</li></ul><blockquote><p>注意：至少创建一个表或视图，否则数据库不能被保存到磁盘中。</p></blockquote><h3 id="往数据表中插入数据"><a href="#往数据表中插入数据" class="headerlink" title="往数据表中插入数据"></a>往数据表中插入数据</h3><pre><code>sqlite&gt; insert into user(id, name, age) values(1, &apos;Micheal&apos;, 20);sqlite&gt; insert into user(id, name, age) values(2, &apos;Jenny&apos;, 22);sqlite&gt; insert into user(name, age) values(&apos;Bob&apos;, 19);sqlite&gt; insert into user(name, age) values(&apos;Kerk&apos;, 20);</code></pre><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><pre><code>sqlite&gt; select * from user;</code></pre><p><img src="/img/2015-8-3-2.png" alt="查询数据"></p><h3 id="设置格式化查询结果"><a href="#设置格式化查询结果" class="headerlink" title="设置格式化查询结果"></a>设置格式化查询结果</h3><pre><code>sqlite&gt; .mode column;  sqlite&gt; .header on;  sqlite&gt; select * from user; </code></pre><ul><li>.mode column 将设置为列显示模式</li><li>.header 将显示列名。</li></ul><p><img src="/img/2015-8-3-3.png" alt="格式化查询结果"></p><h3 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h3><h4 id="增加列"><a href="#增加列" class="headerlink" title="增加列"></a>增加列</h4><pre><code>sqlite&gt; alter table user add column email text not null default &apos;&apos; collate nocase;</code></pre><h4 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a>显示表结构</h4><pre><code>sqlite&gt; .schema user</code></pre><p><img src="/img/2015-8-3-4.png" alt="显示user表结构"></p><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><pre><code>sqlite&gt; create view nameview as select id,name from user;</code></pre><ul><li>取 user 表的 id,name 两列创建视图</li></ul><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><pre><code>sqlite&gt; create index test_idx on user(name);</code></pre><ul><li>为 user 表的 name 列创建索引</li></ul><h3 id="获取所有表和视图"><a href="#获取所有表和视图" class="headerlink" title="获取所有表和视图"></a>获取所有表和视图</h3><pre><code>sqlite&gt; .tables</code></pre><p><img src="/img/2015-8-3-5.png" alt="列出所有表和视图"></p><h3 id="获取指定表的索引列表"><a href="#获取指定表的索引列表" class="headerlink" title="获取指定表的索引列表"></a>获取指定表的索引列表</h3><pre><code>sqlite&gt; .indices user</code></pre><p><img src="/img/2015-8-3-6.png" alt="列出 user 表的索引"></p><h3 id="数据库导出"><a href="#数据库导出" class="headerlink" title="数据库导出"></a>数据库导出</h3><pre><code>sqlite&gt; .output test.sql  sqlite&gt; .dump  sqlite&gt; .output stdout</code></pre><blockquote><p><code>.ouput</code> 命令将输出重定向到文件，导出后，将输出重定向回控制台( stdout )</p></blockquote><p><img src="/img/2015-8-3-7.png" alt="test.sql文件内容"></p><h3 id="从-sql-文件导入数据库"><a href="#从-sql-文件导入数据库" class="headerlink" title="从 sql 文件导入数据库"></a>从 sql 文件导入数据库</h3><pre><code>sqlite&gt; .read test.sql </code></pre><h3 id="格式化输出数据到-CSV-格式"><a href="#格式化输出数据到-CSV-格式" class="headerlink" title="格式化输出数据到 CSV 格式"></a>格式化输出数据到 CSV 格式</h3><pre><code>sqlite&gt; .output test.csv sqlite&gt; .separator ,  sqlite&gt; select * from test;  sqlite&gt; .output stdout </code></pre><p><img src="/img/2015-8-3-8.png" alt="test.csv 文件内容"></p><h3 id="从-CSV-文件导入数据到表中"><a href="#从-CSV-文件导入数据到表中" class="headerlink" title="从 CSV 文件导入数据到表中"></a>从 CSV 文件导入数据到表中</h3><pre><code>sqlite&gt; create table newtable ( id integer primary key, value text );  sqlite&gt; .import [filename.csv ] newtable </code></pre><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><pre><code>/* usage: sqlite3 [database] .dump &gt; [filename] */  sqlite3 test.db .dump &gt; backup.sql</code></pre><h3 id="恢复数据库"><a href="#恢复数据库" class="headerlink" title="恢复数据库"></a>恢复数据库</h3><pre><code>/* usage: sqlite3 [database ] &lt; [filename ] */  sqlite3 mytable.db &lt; backup.sql </code></pre>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlite </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vim学习笔记</title>
      <link href="/2015/07/26/Vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2015/07/26/Vim%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>vim 是从 vi 发展出来的一个文本编辑器，在程序猿中被广泛使用。和Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="Vim的模式"><a href="#Vim的模式" class="headerlink" title="Vim的模式"></a>Vim的模式</h3><p>Vim 和 vi 一样，仅仅通过键盘来在这些模式之中切换。这就使得 Vim 可以不用进行菜单或者鼠标操作，并且最小化组合键的操作。对文字录入员或者程序员可以大大增强速度和效率。</p><h4 id="Vim具有6种基本模式："><a href="#Vim具有6种基本模式：" class="headerlink" title="Vim具有6种基本模式："></a>Vim具有6种基本模式：</h4><ul><li><p>普通模式(Normal mode)</p><pre><code>在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。Vim强大的编辑能来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令dd删除当前行，但是第一个&quot;d&quot;的后面可以跟另外的移动命令来代替第二个d，比如用移动到下一行的&quot;j&quot;键就可以删除当前行和下一行。另外还可以指定命令重复次数，2dd（重复dd两次），和dj的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按a（append／追加）键或者i（insert／插入）键。</code></pre></li><li><p>插入模式(Insert mode)</p><pre><code>在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。在插入模式中，可以按ESC键回到普通模式。</code></pre></li><li><p>可视模式(Visual mode)</p><pre><code>这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的&quot;文本对象&quot;也能和移动命令一样用在这个模式中。</code></pre></li><li><p>选择模式(Select mode)</p><pre><code>这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</code></pre></li><li><p>命令行模式(Command line mode)</p><pre><code>在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</code></pre></li><li><p>Ex模式(Ex mode)</p><pre><code>这和命令行模式比较相似，在使用:visual命令离开Ex模式前，可以一次执行多条命令。这其中我们常用到就是普通模式、插入模式和命令行模式，本课程也只涉及这三个常用模式的内容</code></pre></li></ul><h4 id="三种常用模式"><a href="#三种常用模式" class="headerlink" title="三种常用模式"></a>三种常用模式</h4><ol><li>普通模式</li><li>插入模式</li><li><p>命令行模式</p><pre><code>vim 启动时即进入**普通模式**，在__普通模式__中，按 `i`（插入）或 `a`（附加）键都可以进入**插入模式**，普通模式中，按 `:` 进入命令行模式。命令行模式中输入 `wq` 回车后保存并退出 vim。</code></pre></li></ol><h3 id="vim的常用操作"><a href="#vim的常用操作" class="headerlink" title="vim的常用操作"></a>vim的常用操作</h3><h4 id="普通模式："><a href="#普通模式：" class="headerlink" title="普通模式："></a>普通模式：</h4><p>光标移动：</p><ul><li><code>h</code>, <code>j</code>, <code>k</code>, <code>l</code> 或使用方向键 可以移动光标。</li><li><code>w</code>, <code>b</code> 分别为移动到 下一个/上一个 单词</li></ul><p>退出：</p><ul><li><code>Shift+zz</code> 保存退出 vim</li></ul><p>删除文本：</p><ul><li><code>x</code> 删除游标所在的字符</li><li><code>X</code> 删除游标所在前一个字符</li><li><code>Delete</code> 同 <code>x</code></li><li><code>dd</code> 删除整行</li><li><code>dw</code> 删除一个单词（不适用中文）</li><li><code>d$</code> 或 <code>D</code> 删除至行尾</li><li><code>d^</code> 删除至行首</li><li><code>dG</code> 删除到文档结尾处</li><li><p><code>d1G</code> 删至文档首部</p><pre><code>除此之外，你还可以在命令之前加上数字，表示一次删除多行，如：    2dd表示一次删除2行 </code></pre></li></ul><h4 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式:"></a>插入模式:</h4><p>命令行模式 进入 插入模式：</p><ul><li><code>i</code> 光标处进行编辑</li><li><code>I</code> 行首插入</li><li><code>A</code> 行末插入</li><li><code>a</code> 光标后编辑</li><li><code>o</code> 光标后插入新行</li><li><code>O</code> 光标前插入新行</li><li><code>cw</code> 替换从光标所在位置后到一个单词结尾的字符</li></ul><h4 id="命令行模式："><a href="#命令行模式：" class="headerlink" title="命令行模式："></a>命令行模式：</h4><p>退出：</p><ul><li><code>w</code> 回车，保存文档</li><li><code>w 文件路径</code> 另存为</li><li><code>saveas 文件路径</code> 另存为</li><li><code>q!</code> 强制退出</li><li><code>q</code> 退出</li><li><code>wq!</code> 强制保存并退出</li><li><code>x</code> 保存并退出</li><li><code>wq</code> 保存并退出</li></ul>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java图形界面编程（Swing可拔插外观样式）</title>
      <link href="/2015/07/24/Java%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8F%AF%E6%8B%94%E6%8F%92%E5%A4%96%E8%A7%82%E6%A0%B7%E5%BC%8F%EF%BC%89/"/>
      <url>/2015/07/24/Java%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B%EF%BC%88%E5%8F%AF%E6%8B%94%E6%8F%92%E5%A4%96%E8%A7%82%E6%A0%B7%E5%BC%8F%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="Swing可拔插式外观样式"><a href="#Swing可拔插式外观样式" class="headerlink" title="Swing可拔插式外观样式"></a>Swing可拔插式外观样式</h2><p>相比于 AWT ，Swing 具有一个重要的优势—— 允许开发者定制组件的外观样式。而 AWT 则只能使用底层操作系统提供的组件外观样式。</p><p>Swing 的这个特性为美化程序外观样式提供了足够的灵活性。</p><p>该特性被称为 <strong>可拔插式外观样式（pluggable look-and-feel，PLAF）</strong></p><blockquote><p>提示：可以参考QQ的皮肤切换功能。</p></blockquote><p>而且，Swing 默认提供了一些外观样式供开发者使用。其中，<strong>“metal”</strong> 是默认使用的样式，而 <strong>“nimbus”</strong> 是Java7新增的样式。</p><p>除了不同平台上相同的外观样式，不同平台上还有特定的外观样式。</p><p>程序的外观样式由 <em>javax.swing.UIMangager</em> 类管理。<em>UIManager</em> 类可以为程序切换不同的外观样式。</p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre><code>import javax.swing.*;import java.awt.*;import java.awt.event.ItemEvent;import java.awt.event.ItemListener;/** * PLAF(Pluggable look and feel) * Created by jiawen on 2015/7/24. */public class Plaf {    public void selectPlaf() {        final JFrame frame = new JFrame();        //获得系统自带的所有外观样式信息        UIManager.LookAndFeelInfo[] lafs = UIManager.getInstalledLookAndFeels();        JComboBox combo = new JComboBox(lafs);        combo.addItemListener(new ItemListener() {            @Override            public void itemStateChanged(ItemEvent e) {                if (e.SELECTED == e.getStateChange()) {                    //如果状态改变为选中，则...                    UIManager.LookAndFeelInfo info = (UIManager.LookAndFeelInfo) e.getItem();                    try {                        //设置新的外观样式                        UIManager.setLookAndFeel(info.getClassName());                        //更新界面                        SwingUtilities.updateComponentTreeUI(frame);                    } catch (ClassNotFoundException e1) {                        e1.printStackTrace();                    } catch (InstantiationException e1) {                        e1.printStackTrace();                    } catch (IllegalAccessException e1) {                        e1.printStackTrace();                    } catch (UnsupportedLookAndFeelException e1) {                        e1.printStackTrace();                    }                }            }        });        frame.add(combo, BorderLayout.NORTH);        frame.add(new JButton(&quot;按钮&quot;), BorderLayout.SOUTH);        frame.setTitle(&quot;可拔插外观样式示例&quot;);        frame.setSize(600, 300);        frame.setVisible(true);        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    }    public static void main(String[] args) {        new Plaf().selectPlaf();    }}</code></pre><h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><h3 id="外观样式选择下拉框"><a href="#外观样式选择下拉框" class="headerlink" title="外观样式选择下拉框"></a>外观样式选择下拉框</h3><p><img src="/img/2015-7-24-0.png" alt="外观样式选择下拉框"></p><h3 id="默认外观样式"><a href="#默认外观样式" class="headerlink" title="默认外观样式"></a>默认外观样式</h3><p><img src="/img/2015-7-24-1.png" alt="metal外观样式"></p><h3 id="nimbus外观样式"><a href="#nimbus外观样式" class="headerlink" title="nimbus外观样式"></a>nimbus外观样式</h3><p><img src="/img/2015-7-24-2.png" alt="nimbus外观样式"></p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 图形界面编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VPS主机搭建VPN</title>
      <link href="/2015/05/28/VPS%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BAVPN/"/>
      <url>/2015/05/28/VPS%E4%B8%BB%E6%9C%BA%E6%90%AD%E5%BB%BAVPN/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当你拥有一台国外的VPS的时候，你就可以用来搭建VPN，然后就能翻墙了（翻墙你都不知道的话，先去百度下吧）。PS：写完我才发现，一般人还是看不懂的。</p><p><strong>搭建VPN的主要分为两个步骤</strong>：</p><ul><li>安装pptpd，并配置</li><li>安装iptables,配置iptables</li></ul><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="pptpd"><a href="#pptpd" class="headerlink" title="pptpd:"></a>pptpd:</h3><p>pptp全称（Point to Point Tunneling Protocol），点对点隧道协议。是一种支持多协议虚拟专用网络技术[<a href="http://baike.baidu.com/view/32771.html" target="_blank" rel="noopener">1</a>]。就是利用它来实现的VPN功能。</p><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables:"></a>iptables:</h3><p>iptables 是linux系统下的应用层防火墙工具。我们用它主要用来控制网络信息的转发，使服务器能够起到代理作用，可以理解为跳板吧。同时，可以用来限制访问。</p><h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>操作系统：Ubuntu14.04 x86</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>远程登陆系统，进入shell,此时一般已经为root用户。<br><img src="/img/2015-5-28-6.png" alt="shell界面"></p><h2 id="pptpd安装与配置"><a href="#pptpd安装与配置" class="headerlink" title="pptpd安装与配置"></a>pptpd安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>输入命令</p><pre><code>apt-get install pptpd</code></pre><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>编辑配置文件</p><pre><code>vi /etc/pptpd.conf</code></pre><p>找到并修改ip<br>这里假设你的VPS的IP地址为：138.128.193.121</p><pre><code>localip 138.128.193.121remoteip 138.128.193.121-254,138.128.193.1</code></pre><p>如图<br><img src="/img/2015-5-28-7.png" alt="/etc/pptpd.conf"></p><p><strong>设置DNS</strong></p><p>打开文件</p><pre><code>vi /etc/ppp/pptpd-options</code></pre><p>修改DNS为google的DNS</p><pre><code>ms-dns 8.8.8.8ms-dns 8.8.4.4</code></pre><p>设置账号（此处的账号就是你将来用来登陆VPN的账号）：</p><pre><code>vi /etc/ppp/chap-secrets</code></pre><p>添加一行，依次为：用户名，服务，密码，限制IP</p><pre><code>xiongvpn pptpd passwd123 *...</code></pre><p>星号表示，不限制ip，因为你以后用的时候，自己设备的ip可能有变化，所以这里不设限制。此处可以设置多行，也就是可以设置许多的账户。弄个自动修改的机制的话，就可以在线卖VPN了。</p><p>重启服务：</p><pre><code>/etc/init.d/pptpd restart</code></pre><p><strong>设置IP转发:</strong></p><p>打开文件</p><pre><code>vi /ect/sysctl.conf</code></pre><p>去掉文件中一行前的注释符号<code>#</code></p><pre><code>net.ipv4.ip_forward=1</code></pre><p>使它立刻生效</p><pre><code>sysctl -p</code></pre><h2 id="iptables安装与配置"><a href="#iptables安装与配置" class="headerlink" title="iptables安装与配置"></a>iptables安装与配置</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><pre><code>apt-get install iptables</code></pre><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>假设你的VPS的IP地址为：138.128.193.121</p><p>建立一个NAT(Network Address Translation，网络地址转换):</p><pre><code>iptables -t nat -A POSTROUTING -s 138.128.193.0/24 -o eth0 -j MASQUERADE</code></pre><p>设置MTU，防止包过大：</p><pre><code>iptables -A FORWARD -s 138.128.193.0/24 -p tcp -m tcp --tcp-flags SYN,RST SYN -j TCPMSS --set-mss 1200</code></pre><p>将规则保存，使重启后规则不丢失：</p><pre><code>iptables-save &gt;/etc/iptables-rules</code></pre><p>编辑网卡文件，加载网卡时自动加载规则</p><pre><code>vi  /etc/network/interfaces</code></pre><p>末尾加入：</p><pre><code>pre-up iptables-restore &lt;/etc/iptables-rules</code></pre><p>检查pptp默认1723端口是否监听中：<br>netstat -anlp |grep :1723</p><h3 id="VPN的使用"><a href="#VPN的使用" class="headerlink" title="VPN的使用"></a>VPN的使用</h3><p>可以参考<a href="http://jingyan.baidu.com/article/4f7d5712ac8a611a201927e0.html" target="_blank" rel="noopener">百度经验_浙江大学VPN设置方法-WIN7</a></p><p>主要会用到的信息：</p><ul><li>VPS的IP地址</li><li>之前在<code>chap-secrets</code>文件中添加的用户名与密码。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="http://baike.baidu.com/view/32771.html" target="_blank" rel="noopener">百度百科_PPTP</a></p><p>[2] <a href="http://linux.cn/article-3376-1.html" target="_blank" rel="noopener">如何在Ubuntu下配置pptp vpn</a></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何搭建一个一年只需4美元的VPN</title>
      <link href="/2015/05/26/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%80%E5%B9%B4%E5%8F%AA%E9%9C%804%E7%BE%8E%E5%88%80%E7%9A%84VPN%EF%BC%88%E6%90%9E%E6%9C%BA%E7%AF%87%EF%BC%89/"/>
      <url>/2015/05/26/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%80%E5%B9%B4%E5%8F%AA%E9%9C%804%E7%BE%8E%E5%88%80%E7%9A%84VPN%EF%BC%88%E6%90%9E%E6%9C%BA%E7%AF%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>今天教大家怎么搭建一个一年只需要4刀的VPN服务器。大家只需照做，就可以建立一个属于自己的VPN服务器，然后通过VPN登录，就可以访问国外的网络，虽然速度有时候不太稳定，但对于查询资料，或是上FB，twitter而言足够。另外，这里搭建的VPN服务器，所有的设备都可以登录使用，无论是电脑还是手机，并且无需安装额外的软件。我的选择的服务器在美国西海岸洛杉矶机房，是四个可选机房中最快的一个，个人使用下来，一般白天比较快，进网页，google什么的很流畅，晚上使用的话就可能会慢的不行。我猜想是因为时差的原因，这边白天刚好网络情况比较好。</p><pre><code>声明：希望大家做一个理性的人，好好利用VPN进行科学上网，不要做违反国家法律法规的事情。</code></pre><p>通常，搭建VPN服务器，主要分为以下几个步骤：</p><ol><li>租借一台中国可以访问的国外的VPS</li><li>安装Linux操作系统</li><li>安装pptpd，配置pptpd</li><li>安装iptables，配置iptables</li></ol><h2 id="主要名词解释"><a href="#主要名词解释" class="headerlink" title="主要名词解释"></a>主要名词解释</h2><h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>VPN全称Virtual Private Network，即虚拟专用网络。主要作用是在公用网络上建立专用网络，进行加密通讯。VPN可通过服务器、硬件、软件等多种方式实现[<a href="http://baike.baidu.com/link?url=qvo9sQken7Ro82iiBrqXAa6SCLK1d0uz18SDXI_1EfkeCAp6una6iCdon_yLM-1UUTUoWcRy1w1-4tHcjed84KaauuRk6LK-049BUXzI_7bZJgurZ6REZQQUnXRA8Nus" title="百度百科：VPN" target="_blank" rel="noopener">1</a>]。</p><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><p>VPS全称Virtual Private Server，即虚拟专用服务器。使用虚拟化技术，可以将一台物理服务器划分为多个虚拟服务器[<a href="http://baike.baidu.com/link?url=E-TgaZ143deGuyN_LAoiVfMHnG-kiUyP-g6A3R1P3vqsvtdVIxrPjz1eX0asIuDjdg0E98lS8hgO5UmOZXhN9_" title="百度百科：VPS" target="_blank" rel="noopener">2</a>]。</p><p>通俗的说，就是利用软件对一台服务器的资源（硬盘空间、内存空间、计算能力、网络带宽等）进行分割，划分成多个虚拟的服务器来进行使用。</p><p>类似于房东将一个大房子分隔成多个小房间，然后出租给多个租户。</p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="租借国外VPS"><a href="#租借国外VPS" class="headerlink" title="租借国外VPS"></a>租借国外VPS</h3><p>VPS的价格各不相同。厂商不同，所提供的VPS质量各不相同，价格也不相同。相同厂商的VPS的价格，通常与VPS的硬件配置与网络资源（内存大小、硬盘大小、CPU核心数量、带宽大小、流量等）相关。配置越高，拥有的网络资源越多，价格就越高。</p><p>我们搭建VPN服务器所需要的配置并不高，然而市场上的VPS通常为中小企业网站提供，最低的配置对我们而言都过剩了，价格也相对比较贵，通常几美元至几十美元每月。</p><p>我们所要使用的4美元/年的VPS，是<a href="https://bandwagonhost.com/aff.php?aff=3169" target="_blank" rel="noopener">bandwagonhost(搬瓦工)</a>提供的微型VPS。直接上这个厂商的官方网站，你可能找不到我们所需要的名为<code>Micro-64</code>的微型VPS（首页上找不到的O(∩_∩)O）所以我提供一个超链接，方便你找到它[<a href="https://bandwagonhost.com/cart.php" target="_blank" rel="noopener">Micro-64</a>]，位于页面中间位置偏上一点点，或者你直接按<code>Ctrl+F</code>调出浏览器搜索，搜<code>Micro-64</code>直接定位。</p><p>该Micro-64 vps的配置为：</p><ul><li>HDD: 1.5 GB 机械硬盘空间： 1.5GB</li><li>RAM: 64 MB 内存大小： 64MB</li><li>CPU: 1x Intel Xeon</li><li>BW: 100 GB/mo： 流量：100GB/月</li><li>价格： $3.99 USD/年</li></ul><p>虽然看上去配置很低，但对于只需要跑几个软件程序的VPN服务器而言已经足够了。访问国外网站速度的瓶颈关键在于当前网络连接的拥塞情况。这个有时候也是没办法的事情，网络质量高的VPS价格也非常贵，所幸，这个VPS还是挺好用的。当然，也有配置稍微高一点，流量大一点的<code>Micro-96</code>、<code>Micro-128</code>。其实，以我们的网速及使用频率，<code>100GB/月</code>够用了，我用半个多月了，才用了不到<strong>5GB</strong>不到，还是开着更新了好多的软件。</p><pre><code>其实这个VPS就是全文关键啦，用来搭建VPN比较经济实惠，会搭的人就可以散了。</code></pre><p><strong>购买步骤</strong>：</p><ol><li><p>官网注册个账号（这里有个比较郁闷的问题是，注册的时候验证码的生成与google有点关系，所以需要翻墙才能显示出来…呵呵）</p></li><li><p>然后再点击之前的那个购物车，找到<code>Micro-64</code>，然后点击<code>Order Now</code>下单。<br><img src="/img/2015-5-28-1.png" alt="Mirco-64"></p></li><li><p>接下来跳转至了<code>Product Configuraton</code>页面，因为默认地点就是洛杉矶，不用修改，直接点<code>Add to Cart</code>按钮。<br><img src="/img/2015-5-28-2.png" alt="Add to Cart"></p></li><li><p>接下来是<code>Order Summary</code>,如果没有别的要买了，就<code>Check out</code>。<br><img src="/img/2015-5-28-3.png" alt="Alt Check out"></p></li><li><p>接下来就是<code>Check out</code>页面啦，也就是确认一下你的具体信息什么的，然后就可以支付了。</p><pre><code>注意：需要用`Paypal`支付，没有的话就去注册个。一开始我以为必须要用信用卡，后来发现普通银联卡也可以绑定。</code></pre></li><li><p>付完款后，就完成购买了。</p></li><li><p>回到搬瓦工的网站（如果没登陆的话，点击右上角的<code>Client Area</code>登陆），在导航栏点击<code>Services</code>，打开<code>My Services</code>。结果如图所示，就是你的VPS了。<br><img src="/img/2015-5-28-4.png" alt="VPS列表"><br>点击红框标出的<code>KiwiVM Control Panel</code>，可以进入你的VPS管理面板。<br><img src="/img/2015-5-28-5.png" alt="VPS管理面板"><br>可以看到VPS的当前运行状态，以及流量的使用量。</p></li><li><p>默认的OS(操作系统)应该是CentOS的，但因为本人常用Ubuntu，所以重新安装了Ubuntu系统。因为后面的步骤与系统有一定关联，所以你也可以重新安装一个新系统。点击左侧菜单栏中<code>Install new OS</code>,然后选择<code>Ubuntu-14.04-x86</code>，勾选下面的<code>I agree...</code>，点击<code>Reload</code>,等待数分钟就可以了。安装完成后，应该会有邮件通知，同时会告诉你新的密码。</p></li></ol><p>这样，主机基本准备好了，接下来就是对VPS进行配置了，主要需要Linux命令行的一些知识。</p><p>这里有几点需要注意的信息，下面会有用到：</p><ol><li>VPS的<strong>IP</strong>，在之前的第7步中可以看到。</li><li>VPS的<strong>SSH Port</strong>,即SSH端口号,同上，可以在管理面板的<code>Main controls</code>中看到。</li><li>VPS的<strong>Root密码</strong>，邮箱里会有邮件，或者自己在管理面板的菜单栏选择<code>Root password modification</code>进行修改。</li></ol><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>要配置VPS，就必须远程登陆这台主机。</p><p>你有两种方式可供选择：</p><ol><li><p>使用SSH登陆工具，然后根据之前的IP、端口号、密码信息进行远程登陆。</p></li><li><p>管理面板中，点击左侧菜单栏中的<code>Root shell-interactive</code>，启动一个HTML5的shell界面。<br><img src="/img/2015-5-28-6.png" alt="HTML5 shell交互界面"><br>速度还是有点慢，一卡一卡的。</p></li></ol><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>主机配置见下一篇<a href="/2015/05/28/VPS主机搭建VPN/">《VPS主机搭建VPN》</a>。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] <a href="http://baike.baidu.com/link?url=qvo9sQken7Ro82iiBrqXAa6SCLK1d0uz18SDXI_1EfkeCAp6una6iCdon_yLM-1UUTUoWcRy1w1-4tHcjed84KaauuRk6LK-049BUXzI_7bZJgurZ6REZQQUnXRA8Nus" title="百度百科：VPN" target="_blank" rel="noopener">百度百科：VPN</a></p><p>[2] <a href="http://baike.baidu.com/link?url=E-TgaZ143deGuyN_LAoiVfMHnG-kiUyP-g6A3R1P3vqsvtdVIxrPjz1eX0asIuDjdg0E98lS8hgO5UmOZXhN9_" title="百度百科：VPS" target="_blank" rel="noopener">百度百科：VPS</a></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 科学上网 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习资源汇总</title>
      <link href="/2015/05/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/"/>
      <url>/2015/05/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<ol><li><a href="http://segmentfault.com/a/1190000000413624#articleHeader1" target="_blank" rel="noopener">机器学习指南</a></li><li><a href="http://ml.memect.com/article/machine-learning-guide.html" target="_blank" rel="noopener">机器学习入门资源不完全汇总</a></li><li><a href="http://segmentfault.com/a/1190000000394924" target="_blank" rel="noopener">机器学习的最佳入门资源</a></li></ol><p><strong>持续更新ing…</strong></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 machine learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GPU计算</title>
      <link href="/2015/05/17/GPU%E8%AE%A1%E7%AE%97/"/>
      <url>/2015/05/17/GPU%E8%AE%A1%E7%AE%97/</url>
      <content type="html"><![CDATA[<h1 id="GPU计算"><a href="#GPU计算" class="headerlink" title="GPU计算"></a>GPU计算</h1><p>GPU计算，或称显卡计算，是指用计算机的图形处理器（Graphic Processing Unit，简称GPU）处理计算工作的计算方式。与之对应的是使用计算机处理器的（即Central Processing Unit，简称CPU）CPU计算。</p><h2 id="与CPU计算相比"><a href="#与CPU计算相比" class="headerlink" title="与CPU计算相比"></a>与CPU计算相比</h2><p>GPU在科学计算方面拥有如下的优势：</p><ul><li>GPU由大量的运算单元（核心）组成，并行计算能力远高于CPU。</li><li>通常GPU拥有较普通内存位宽更大、频率更高的专用内存，即显存，适合处理大规模数据。</li></ul><p>综上，CPU适合进行大量同类型数据的密集运算，如密码破译。</p><p>对于适合GPU处理的任务，CPU计算会比CPU计算快2-10倍之多。同时，在分布式计算项目中，GPU计算的得分效率也往往比CPU任务高出很多。</p><h2 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h2><h3 id="硬件需求"><a href="#硬件需求" class="headerlink" title="硬件需求"></a>硬件需求</h3><pre><code>显卡需要CUDA或OpenCL支持，可以使用GPU-Z查看显卡是否具备此功能。</code></pre><h3 id="软件需求"><a href="#软件需求" class="headerlink" title="软件需求"></a>软件需求</h3><pre><code>新版本的Windows XP ATI/AMD显卡驱动不再兼容OpenCL计算，请考虑升级到Windows7或者使用旧版本（可能效率略低）。</code></pre><ul><li>安装相应支持GPU计算的驱动程序</li><li>使用项目方提供的GPU计算专用的客户端/优化计算程序</li><li>计算机程序有权限访问GPU资源</li></ul><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="权限问题"><a href="#权限问题" class="headerlink" title="权限问题"></a>权限问题</h3><p>Windows 下，由于权限控制机制，以独立用户身份运行的 BOINC 无法正常检测 GPU。安装 BOINC 客户端时，请不要选择 “Protected access execution mode”（默认即不选）。</p><p>Linux 下，需要将运行客户端的用户加入适当的用户组（通常是 video），以保证客户端拥有足够的权限使用 GPU 资源。</p><h3 id="资源占用"><a href="#资源占用" class="headerlink" title="资源占用"></a>资源占用</h3><p>GPU 计算可能导致计算机图形界面响应非常缓慢。越是低端的显卡，这种效应越发明显。</p><p>对于多显卡用户，可以禁用负责显示的显卡（通常是集成显卡或核心显卡），以避免影响系统正常使用。</p><h3 id="性能考量"><a href="#性能考量" class="headerlink" title="性能考量"></a>性能考量</h3><p>GPU计算一般需要一些CPU资源进行命令。为了最大化GPU的利用程度，你可以手动提高GPU计算进程优先级以使其获得充足的CPU资源，也可以干脆留出一个CPU线程。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.equn.com/wiki/GPU_%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">GPU计算</a></p>]]></content>
      
      
        <tags>
            
            <tag> 并行计算 </tag>
            
            <tag> GPU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>建筑史观-建筑ABC</title>
      <link href="/2015/05/16/%E5%BB%BA%E7%AD%91%E5%8F%B2%E8%A7%82-%E5%BB%BA%E7%AD%91ABC/"/>
      <url>/2015/05/16/%E5%BB%BA%E7%AD%91%E5%8F%B2%E8%A7%82-%E5%BB%BA%E7%AD%91ABC/</url>
      <content type="html"><![CDATA[<h2 id="史地维度与建筑质感"><a href="#史地维度与建筑质感" class="headerlink" title="史地维度与建筑质感"></a>史地维度与建筑质感</h2><h3 id="史地维度"><a href="#史地维度" class="headerlink" title="史地维度"></a>史地维度</h3><p>建筑是历史范畴的</p><ul><li>历史维度：与历史有关</li><li>在地维度：与地域相关</li></ul><h3 id="建筑质感"><a href="#建筑质感" class="headerlink" title="建筑质感"></a>建筑质感</h3><p>不是随意追求质感</p><p>能不能有史地维度的质感？</p><h2 id="三元词与建筑演化"><a href="#三元词与建筑演化" class="headerlink" title="三元词与建筑演化"></a>三元词与建筑演化</h2><h3 id="三元词"><a href="#三元词" class="headerlink" title="三元词"></a>三元词</h3><ul><li>建筑师    （architect）</li><li>建筑    （architecture）</li><li>建筑术    （architectonics）<ul><li>结构 structure </li><li>构造 tectonic （建筑师要做的）</li><li>建造 construction </li></ul></li></ul><p>vitruvious《建筑十书》</p><h3 id="建筑演化"><a href="#建筑演化" class="headerlink" title="建筑演化"></a>建筑演化</h3><p><strong>古典主义</strong></p><ul><li>18世纪(启蒙运动，工业革命)开始，建筑与土木分家，建筑分到艺术学院</li><li>黑格尔美学，将建筑放在艺术之首</li></ul><p><strong>新古典主义</strong></p><ul><li>德国桑佩尔-《建筑四要素》</li></ul><p><strong>现代主义</strong></p><ul><li>20世纪柯布西耶-《走向新建筑》</li></ul><p><strong>后现代主义</strong></p><pre><code>大家觉得失去了精神寄托，觉得建筑缺少了史地维度，觉得时代性压倒了地域性。建筑像产品一样成批量生产，大家不满意了。</code></pre><ul><li>20世纪六七十年代</li><li>文丘里-《建筑的复杂性与矛盾性》</li></ul><h2 id="三原则与建筑理性"><a href="#三原则与建筑理性" class="headerlink" title="三原则与建筑理性"></a>三原则与建筑理性</h2><h3 id="建筑三原则："><a href="#建筑三原则：" class="headerlink" title="建筑三原则："></a>建筑三原则：</h3><ul><li>坚固 durability 持久性</li><li>适用 convenience 便利</li><li>美观 beauty pleasure 美观性</li></ul><h3 id="建筑理性"><a href="#建筑理性" class="headerlink" title="建筑理性"></a>建筑理性</h3><p>建筑是浪费空间的艺术？</p><p>资源的有效性和建筑的适用性将使建筑的理性永远占据主流的位置。感性的东西是美的点缀。</p><p>理性主义</p><ul><li><p>工具性</p></li><li><p>价值性</p></li></ul><h2 id="课后问答"><a href="#课后问答" class="headerlink" title="课后问答"></a>课后问答</h2><p><strong>骨架与屋顶(frame and roof)</strong></p><ul><li>沙逊大厦（Sassoon House）和平饭店–钢筋混凝土结构</li><li>它的金字塔顶–钢结构</li></ul><p><strong>建筑是什么</strong></p><ul><li>支撑结构</li><li>围护体</li></ul>]]></content>
      
      <categories>
          
          <category> 建筑学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 建筑学 艺术 建筑史 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo部署时git没有任何文件上传</title>
      <link href="/2015/05/16/hexo%E9%83%A8%E7%BD%B2%E6%97%B6git%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2015/05/16/hexo%E9%83%A8%E7%BD%B2%E6%97%B6git%E6%B2%A1%E6%9C%89%E4%BB%BB%E4%BD%95%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      <content type="html"><![CDATA[<p>跟着网上教程搭建hexo的时候碰到一个问题<br>当我使用</p><pre><code>$ hexo d</code></pre><p>部署hexo的时候，我的gitpage怎么都没反应</p><p>然后我捣鼓了半天，都没搞明白怎么回事</p><p>后来发现我这里生成的没有<code>.deploy</code>目录，只有一个<code>.deploy_git</code>目录。然后手动改名</p><pre><code>$ mv .deploy_git .deploy</code></pre><p>重新部署，发现就好。真是无语了，暂时不知道什么缘故。</p>]]></content>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
